#!/usr/bin/env python3
"""Render GitOps parameters for demo ingress hosts.

The script keeps the ingress parameters declarative by sourcing a single
LoadBalancer IP (from Terraform output, kubectl or manual input) and writing the
Git-managed ``clusters/aks/apps/params.env`` file. It can optionally patch the
Helm values that back the ingress-nginx ApplicationSet so the static public IP
and resource group stay in sync with Terraform outputs. Compared to the previous
imperative helper it focuses on idempotence and testability so CI can assert the
rendered file matches expectations.
"""

from __future__ import annotations

import argparse
import ipaddress
import json
import socket
import subprocess
from pathlib import Path

import yaml

PARAMS_PATH = Path("clusters/aks/apps/params.env")
VALUES_PATH = Path("clusters/aks/addons/ingress-nginx.values.yaml")
DEFAULT_INGRESS_CLASS = "nginx"


def _run(cmd: list[str]) -> str:
    result = subprocess.run(cmd, check=True, capture_output=True, text=True)
    return result.stdout.strip()


def read_ip_from_kubectl(namespace: str, service: str) -> str:
    data = _run(
        [
            "kubectl",
            "get",
            f"service/{service}",
            "-n",
            namespace,
            "-o",
            "json",
        ]
    )
    parsed = json.loads(data)
    status = parsed.get("status", {})
    ingress = status.get("loadBalancer", {}).get("ingress", [])
    if not ingress:
        raise RuntimeError("LoadBalancer ingress not published yet; retry later.")
    ip = ingress[0].get("ip") or ingress[0].get("hostname")
    if not ip:
        raise RuntimeError("Ingress service did not expose an IP or hostname.")
    return ip


def parse_ip(raw: str) -> str:
    try:
        addr = ipaddress.ip_address(raw)
        return str(addr)
    except ValueError as exc:
        raise ValueError(f"{raw!r} is not a valid IP address") from exc


def normalise_ip(raw: str) -> str:
    try:
        return parse_ip(raw)
    except ValueError as exc:
        raise argparse.ArgumentTypeError(str(exc)) from exc


def build_params(ip: str, ingress_class: str) -> str:
    keycloak_host = f"kc.{ip}.nip.io"
    midpoint_host = f"mp.{ip}.nip.io"
    return (
        "# Generated by scripts/render_hosts.py\n"
        "# Commit this file so Argo CD reconciles the ingress configuration.\n"
        f"ingressClass={ingress_class}\n"
        f"keycloakHost={keycloak_host}\n"
        f"midpointHost={midpoint_host}\n"
    )


def write_params(content: str, destination: Path = PARAMS_PATH) -> None:
    destination.write_text(content, encoding="utf-8")


def update_ingress_values(
    ip: str, resource_group: str, values_path: Path = VALUES_PATH
) -> None:
    data = yaml.safe_load(values_path.read_text(encoding="utf-8"))
    controller = data.setdefault("controller", {})
    service = controller.setdefault("service", {})
    annotations = service.setdefault("annotations", {})
    annotations[
        "service.beta.kubernetes.io/azure-load-balancer-resource-group"
    ] = resource_group
    service["loadBalancerIP"] = ip
    values_path.write_text(
        yaml.safe_dump(data, sort_keys=False), encoding="utf-8"
    )


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description=__doc__)
    source = parser.add_mutually_exclusive_group(required=True)
    source.add_argument("--ip", type=parse_ip, help="LoadBalancer IP address")
    source.add_argument(
        "--kubectl",
        action="store_true",
        help="Resolve the ingress IP from the ingress-nginx service",
    )
    parser.add_argument(
        "--namespace",
        default="ingress-nginx",
        help="Ingress controller namespace (default: ingress-nginx)",
    )
    parser.add_argument(
        "--service",
        default="ingress-nginx-controller",
        help="Ingress service name (default: ingress-nginx-controller)",
    )
    parser.add_argument(
        "--ingress-class",
        default=DEFAULT_INGRESS_CLASS,
        help="IngressClass name stored in params.env (default: nginx)",
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=PARAMS_PATH,
        help="Path to the params.env file (default: clusters/aks/apps/params.env)",
    )
    parser.add_argument(
        "--resource-group",
        default="",
        help="Azure resource group that owns the ingress public IP",
    )
    parser.add_argument(
        "--ingress-values",
        type=Path,
        default=VALUES_PATH,
        help="Ingress-NGINX values file to patch",
    )
    parser.add_argument(
        "--update-values",
        action="store_true",
        help="Also patch the ingress-nginx values file with the resolved IP",
    )
    return parser.parse_args()


def main() -> None:
    args = parse_args()
    if args.kubectl:
        raw_ip = read_ip_from_kubectl(args.namespace, args.service)
        try:
            ip = parse_ip(raw_ip)
        except ValueError:
            ip = parse_ip(socket.gethostbyname(raw_ip))
    else:
        ip = args.ip
    content = build_params(ip, args.ingress_class)
    write_params(content, args.output)
    if args.update_values:
        if not args.resource_group:
            raise SystemExit("--resource-group is required when --update-values is set")
        update_ingress_values(ip, args.resource_group, args.ingress_values)


if __name__ == "__main__":
    main()
