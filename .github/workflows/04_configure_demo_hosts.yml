name: 04 - Configure demo hosts (nip.io) & Ingresses

on:
  workflow_dispatch:
    inputs:
      RESOURCE_GROUP:
        description: 'AKS Resource Group (from TF outputs)'
        required: true
        default: 'rwsdemo-rg'
      AKS_NAME:
        description: 'AKS cluster name (from TF outputs)'
        required: true
        default: 'rwsdemo-aks'
      NAMESPACE_IAM:
        description: 'Namespace for IAM stack (Keycloak + midPoint)'
        required: true
        default: 'iam'
      KEYCLOAK_SERVICE_NAME:
        description: 'Keycloak Service name (check kubectl -n <ns> get svc)'
        required: true
        default: 'rws-keycloak'
      KEYCLOAK_SERVICE_PORT:
        description: 'Keycloak Service port (8080 for httpEnabled=true)'
        required: true
        default: '8080'

permissions:
  id-token: write
  contents: read

jobs:
  configure:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get AKS credentials
        uses: azure/aks-set-context@v4
        with:
          resource-group: ${{ inputs.RESOURCE_GROUP }}
          cluster-name: ${{ inputs.AKS_NAME }}

      - name: Resolve EXTERNAL_IP for ingress-nginx LoadBalancer
        id: ip
        shell: bash
        run: |
          set -euo pipefail
          echo "Waiting for external IP of ingress-nginx LoadBalancer..."
          for i in {1..15}; do
            EXTERNAL_IP=$(kubectl -n ingress-nginx get svc ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}' || true)
            if [ -n "${EXTERNAL_IP:-}" ]; then break; fi
            echo "Attempt $i: no IP yet, retrying in 10s..."
            sleep 10
          done
          if [ -z "${EXTERNAL_IP:-}" ]; then
            HNAME=$(kubectl -n ingress-nginx get svc ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' || true)
            if [ -n "${HNAME:-}" ]; then
              if ! command -v dig >/dev/null 2>&1; then
                sudo apt-get update >/dev/null 2>&1 && sudo apt-get install -y dnsutils >/dev/null 2>&1
              fi
              EXTERNAL_IP=$(dig +short "$HNAME" | tail -n1 || true)
            fi
          fi
          if [ -z "${EXTERNAL_IP:-}" ]; then
            echo "ERROR: Could not determine external IP/hostname for ingress-nginx-controller."
            kubectl -n ingress-nginx get svc ingress-nginx-controller -o yaml || true
            exit 1
          fi
          KC_HOST="kc.${EXTERNAL_IP}.nip.io"
          MP_HOST="mp.${EXTERNAL_IP}.nip.io"
          echo "EXTERNAL_IP=$EXTERNAL_IP" | tee -a $GITHUB_ENV
          echo "KC_HOST=${KC_HOST}" | tee -a $GITHUB_ENV
          echo "MP_HOST=${MP_HOST}" | tee -a $GITHUB_ENV
          echo "keycloak_url=http://kc.${EXTERNAL_IP}.nip.io" >> $GITHUB_OUTPUT
          echo "midpoint_url=http://mp.${EXTERNAL_IP}.nip.io/midpoint" >> $GITHUB_OUTPUT
          echo "Resolved EXTERNAL_IP: $EXTERNAL_IP"
          echo "Keycloak host: $KC_HOST"
          echo "midPoint host: $MP_HOST"

      - name: Verify nip.io hostnames resolve to EXTERNAL_IP
        shell: bash
        run: |
          set -euo pipefail
          if ! command -v dig >/dev/null 2>&1; then
            sudo apt-get update >/dev/null 2>&1
            sudo apt-get install -y dnsutils >/dev/null 2>&1
          fi
          for host in "$KC_HOST" "$MP_HOST"; do
            echo "Checking DNS for $host ..."
            RESOLVED=$(dig +short "$host" | tail -n1 || true)
            if [ "${RESOLVED}" != "${EXTERNAL_IP}" ]; then
              echo "ERROR: $host resolved to '${RESOLVED:-<empty>}' but expected ${EXTERNAL_IP}."
              dig "$host" || true
              exit 1
            fi
          done
          echo "nip.io DNS looks good for ${EXTERNAL_IP}."

      - name: Update midPoint ingress host via Argo CD
        env:
          MP_HOST: ${{ env.MP_HOST }}
        shell: bash
        run: |
          set -euo pipefail
          echo "Updating Argo CD application patch for midPoint ingress host -> ${MP_HOST}"
          PATCH=$(cat <<EOF
- op: replace
  path: /spec/rules/0/host
  value: ${MP_HOST}
EOF
)
          JSON_PATCH=$(jq -n --arg patch "$PATCH" '{
            "spec": {
              "source": {
                "kustomize": {
                  "patchesJson6902": [
                    {
                      "target": {
                        "group": "networking.k8s.io",
                        "version": "v1",
                        "kind": "Ingress",
                        "name": "midpoint",
                        "namespace": "iam"
                      },
                      "patch": $patch
                    }
                  ]
                }
              }
            }
          }')
          kubectl -n argocd patch application apps --type merge --patch "$JSON_PATCH"
          echo "Current Argo CD patch:"
          kubectl -n argocd get application apps -o json | jq -r '.spec.source.kustomize.patchesJson6902[0].patch'

      - name: Wait for Argo CD to apply midPoint ingress host
        shell: bash
        run: |
          set -euo pipefail
          echo "Waiting for Argo CD application 'apps' to become Synced & Healthy after host update..."
          sync=""
          health=""
          for i in {1..30}; do
            sync=$(kubectl -n argocd get application apps -o jsonpath='{.status.sync.status}' || true)
            health=$(kubectl -n argocd get application apps -o jsonpath='{.status.health.status}' || true)
            echo "Attempt $i: sync=${sync:-<unknown>} health=${health:-<unknown>}"
            if [ "$sync" = "Synced" ] && [ "$health" = "Healthy" ]; then
              break
            fi
            sleep 10
          done
          if [ "$sync" != "Synced" ] || [ "$health" != "Healthy" ]; then
            echo "ERROR: Argo CD application did not reconcile successfully."
            kubectl -n argocd get application apps -o yaml || true
            exit 1
          fi
          echo "Argo CD application apps is Synced & Healthy."

      - name: Create/Update Keycloak Ingress (public)
        env:
          NAMESPACE: ${{ inputs.NAMESPACE_IAM }}
          SVC: ${{ inputs.KEYCLOAK_SERVICE_NAME }}
          PORT: ${{ inputs.KEYCLOAK_SERVICE_PORT }}
        shell: bash
        run: |
          set -euo pipefail
          echo "Reconciling Keycloak public Ingress for host ${KC_HOST} -> ${SVC}:${PORT}"
          kubectl -n "$NAMESPACE" create ingress rws-keycloak-public \
            --class=nginx \
            --rule="${KC_HOST}/=${SVC}:${PORT}" \
            --annotation=nginx.ingress.kubernetes.io/proxy-body-size=16m \
            --dry-run=client \
            -o yaml \
            | kubectl apply -f -
          kubectl -n "$NAMESPACE" get ingress rws-keycloak-public -o wide

      - name: Verify ingress hosts
        env:
          NAMESPACE: ${{ inputs.NAMESPACE_IAM }}
        shell: bash
        run: |
          set -euo pipefail
          MIDPOINT_HOST=$(kubectl -n "$NAMESPACE" get ingress midpoint -o jsonpath='{.spec.rules[0].host}' || true)
          KEYCLOAK_HOST=$(kubectl -n "$NAMESPACE" get ingress rws-keycloak-public -o jsonpath='{.spec.rules[0].host}' || true)
          echo "midPoint ingress host: ${MIDPOINT_HOST:-<missing>}"
          echo "Keycloak ingress host: ${KEYCLOAK_HOST:-<missing>}"
          if [ "${MIDPOINT_HOST:-}" != "$MP_HOST" ]; then
            echo "ERROR: midPoint ingress host mismatch (expected $MP_HOST)."
            kubectl -n "$NAMESPACE" get ingress midpoint -o yaml || true
            exit 1
          fi
          if [ "${KEYCLOAK_HOST:-}" != "$KC_HOST" ]; then
            echo "ERROR: Keycloak ingress host mismatch (expected $KC_HOST)."
            kubectl -n "$NAMESPACE" get ingress rws-keycloak-public -o yaml || true
            exit 1
          fi
          echo "Ingress hosts match expected nip.io values."

      - name: Smoke-test endpoints
        env:
          NAMESPACE: ${{ inputs.NAMESPACE_IAM }}
        shell: bash
        run: |
          set -euo pipefail
          echo "Keycloak:  http://${KC_HOST}"
          echo "midPoint:  http://${MP_HOST}/midpoint"
          success=false
          for i in {1..10}; do
            echo "HTTP HEAD try $i ..."
            KC_STATUS=$(curl -sS -o /dev/null -w '%{http_code}' --max-time 5 "http://${KC_HOST}" || echo "000")
            MP_STATUS=$(curl -sS -o /dev/null -w '%{http_code}' --max-time 5 "http://${MP_HOST}/midpoint" || echo "000")
            echo "Keycloak status: ${KC_STATUS}, midPoint status: ${MP_STATUS}"
            if [[ "${KC_STATUS}" =~ ^(200|301|302|401|403)$ ]] && [[ "${MP_STATUS}" =~ ^(200|301|302|401|403)$ ]]; then
              success=true
              break
            fi
            sleep 5
          done
          if [ "$success" = false ]; then
            echo "ERROR: Endpoints are not reachable after multiple attempts."
            kubectl -n "$NAMESPACE" get ingress midpoint -o wide || true
            kubectl -n "$NAMESPACE" get ingress rws-keycloak-public -o wide || true
            exit 1
          fi
          echo "Endpoints returned healthy HTTP status codes."

      - name: Summary
        shell: bash
        run: |
          echo "âœ… Done. Open these URLs in your browser:"
          echo "ðŸ”— Keycloak : http://${KC_HOST}"
          echo "ðŸ”— midPoint : http://${MP_HOST}/midpoint"
