name: "04 - Configure demo hosts (nip.io) & Ingresses"

on:
  workflow_dispatch:
    inputs:
      RESOURCE_GROUP:
        description: 'AKS Resource Group (from TF outputs)'
        required: true
        default: 'rwsdemo-rg'
      AKS_NAME:
        description: 'AKS cluster name (from TF outputs)'
        required: true
        default: 'rwsdemo-aks'
      NAMESPACE_IAM:
        description: 'Namespace for IAM stack (Keycloak + midPoint)'
        required: true
        default: 'iam'
      KEYCLOAK_SERVICE_NAME:
        description: 'Keycloak Service name (check kubectl -n <ns> get svc)'
        required: true
        default: 'rws-keycloak-service'
      KEYCLOAK_SERVICE_PORT:
        description: 'Keycloak Service port (8080 for httpEnabled=true)'
        required: true
        default: '8080'

permissions:
  id-token: write
  contents: read

jobs:
  configure:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get AKS credentials
        uses: azure/aks-set-context@v4
        with:
          resource-group: ${{ inputs.RESOURCE_GROUP }}
          cluster-name: ${{ inputs.AKS_NAME }}

      - name: Resolve EXTERNAL_IP for ingress-nginx LoadBalancer
        id: ip
        shell: bash
        run: |
          set -euo pipefail
          echo "Waiting for external IP of ingress-nginx LoadBalancer..."
          for i in {1..15}; do
            EXTERNAL_IP=$(kubectl -n ingress-nginx get svc ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}' || true)
            if [ -n "${EXTERNAL_IP:-}" ]; then break; fi
            echo "Attempt $i: no IP yet, retrying in 10s..."
            sleep 10
          done
          if [ -z "${EXTERNAL_IP:-}" ]; then
            HNAME=$(kubectl -n ingress-nginx get svc ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' || true)
            if [ -n "${HNAME:-}" ]; then
              if ! command -v dig >/dev/null 2>&1; then
                sudo apt-get update >/dev/null 2>&1 && sudo apt-get install -y dnsutils >/dev/null 2>&1
              fi
              EXTERNAL_IP=$(dig +short "$HNAME" | tail -n1 || true)
            fi
          fi
          if [ -z "${EXTERNAL_IP:-}" ]; then
            echo "ERROR: Could not determine external IP/hostname for ingress-nginx-controller."
            kubectl -n ingress-nginx get svc ingress-nginx-controller -o yaml || true
            exit 1
          fi
          KC_HOST="kc.${EXTERNAL_IP}.nip.io"
          MP_HOST="mp.${EXTERNAL_IP}.nip.io"
          echo "EXTERNAL_IP=$EXTERNAL_IP" | tee -a $GITHUB_ENV
          echo "KC_HOST=${KC_HOST}" | tee -a $GITHUB_ENV
          echo "MP_HOST=${MP_HOST}" | tee -a $GITHUB_ENV
          echo "keycloak_url=http://kc.${EXTERNAL_IP}.nip.io" >> $GITHUB_OUTPUT
          echo "midpoint_url=http://mp.${EXTERNAL_IP}.nip.io/midpoint" >> $GITHUB_OUTPUT
          echo "Resolved EXTERNAL_IP: $EXTERNAL_IP"
          echo "Keycloak host: $KC_HOST"
          echo "midPoint host: $MP_HOST"

      - name: Wait for ingress-nginx controller availability
        shell: bash
        run: |
          set -euo pipefail
          echo "Waiting for ingress-nginx controller deployment to become available..."
          kubectl -n ingress-nginx rollout status deploy/ingress-nginx-controller --timeout=600s

      - name: Identify Azure load balancer for ingress-nginx
        shell: bash
        env:
          RESOURCE_GROUP: ${{ inputs.RESOURCE_GROUP }}
          AKS_NAME: ${{ inputs.AKS_NAME }}
        run: |
          set -euo pipefail

          if ! command -v az >/dev/null 2>&1; then
            echo "Azure CLI not found on runner" >&2
            exit 1
          fi

          echo "Discovering AKS node resource group..."
          NODE_RG=$(az aks show -g "$RESOURCE_GROUP" -n "$AKS_NAME" --query nodeResourceGroup -o tsv)
          if [ -z "${NODE_RG:-}" ]; then
            echo "ERROR: Unable to determine AKS node resource group." >&2
            exit 1
          fi
          echo "NODE_RESOURCE_GROUP=${NODE_RG}" | tee -a "$GITHUB_ENV"
          export NODE_RESOURCE_GROUP="${NODE_RG}"

          python3 <<'PY'
          import json
          import os
          import subprocess
          import sys
          
          external_ip = os.environ.get("EXTERNAL_IP", "").strip()
          node_rg = os.environ.get("NODE_RESOURCE_GROUP", "").strip()
          github_env = os.environ.get("GITHUB_ENV")
          
          if not external_ip:
              print("External IP not available in environment", file=sys.stderr)
              sys.exit(1)
          
          try:
              pip_raw = subprocess.check_output([
                  "az",
                  "network",
                  "public-ip",
                  "list",
                  "--resource-group",
                  node_rg,
                  "--query",
                  f"[?ipAddress=='{external_ip}']",
                  "-o",
                  "json",
              ], text=True)
          except subprocess.CalledProcessError as exc:
              print("Failed to list Azure public IPs:", exc, file=sys.stderr)
              sys.exit(1)
          
          try:
              pip_list = json.loads(pip_raw)
          except json.JSONDecodeError:
              print("Unable to parse Azure public IP list", file=sys.stderr)
              print(pip_raw)
              sys.exit(1)
          
          if not pip_list:
              print(f"No public IP resource in {node_rg!r} matches {external_ip}", file=sys.stderr)
              try:
                  inventory = subprocess.check_output([
                      "az",
                      "network",
                      "public-ip",
                      "list",
                      "--resource-group",
                      node_rg,
                      "--query",
                      "[].{name:name, ip:ipAddress, state:provisioningState}",
                      "-o",
                      "tsv",
                  ], text=True)
                  print("Existing public IPs (name\tip\tstate):")
                  print(inventory.strip() or "<none>")
              except subprocess.CalledProcessError as exc:
                  print("Additionally failed to enumerate all public IPs:", exc, file=sys.stderr)
              sys.exit(1)
          
          pip_entry = pip_list[0]
          ip_config = pip_entry.get("ipConfiguration")
          if isinstance(ip_config, dict):
              ip_config_ids = [ip_config.get("id")]
          elif isinstance(ip_config, list):
              ip_config_ids = [item.get("id") for item in ip_config if isinstance(item, dict)]
          else:
              ip_config_ids = []
          
          ip_config_ids = [item for item in ip_config_ids if item]
          if not ip_config_ids:
              print("The public IP is not attached to a load balancer frontend yet", file=sys.stderr)
              sys.exit(1)
          
          ip_config_id = ip_config_ids[0]
          parts = [segment for segment in ip_config_id.split('/') if segment]
          
          try:
              lb_index = parts.index("loadBalancers")
              frontend_index = parts.index("frontendIPConfigurations")
          except ValueError:
              print(f"Unexpected ipConfiguration id format: {ip_config_id}", file=sys.stderr)
              sys.exit(1)
          
          lb_name = parts[lb_index + 1]
          frontend_name = parts[frontend_index + 1]
          
          print(f"Resolved load balancer: {lb_name} (frontend {frontend_name})")
          
          try:
              lb_raw = subprocess.check_output([
                  "az",
                  "network",
                  "lb",
                  "show",
                  "--resource-group",
                  node_rg,
                  "--name",
                  lb_name,
                  "-o",
                  "json",
              ], text=True)
          except subprocess.CalledProcessError as exc:
              print("Failed to retrieve load balancer details:", exc, file=sys.stderr)
              sys.exit(1)
          
          lb = json.loads(lb_raw)
          rules = lb.get("loadBalancingRules") or []
          target_backend_names = []
          target_rule_names = []
          rule_to_backend = {}

          frontend_suffix = f"/frontendipconfigurations/{frontend_name}".lower()

          for rule in rules:
              frontend_id = (rule.get("frontendIPConfiguration") or {}).get("id", "")
              backend_id = (rule.get("backendAddressPool") or {}).get("id")
              if frontend_id.lower().endswith(frontend_suffix) and backend_id:
                  backend_name = backend_id.split('/')[-1]
                  if backend_name:
                      target_backend_names.append(backend_name)
                  rule_name = rule.get("name")
                  if rule_name:
                      target_rule_names.append(rule_name)
                      if backend_name:
                          rule_to_backend.setdefault(rule_name, backend_name)

          if not target_backend_names:
              # Fallback to all pools that currently reference any backend configs.
              for pool in lb.get("backendAddressPools") or []:
                  if pool.get("backendIpConfigurations"):
                      name = pool.get("name")
                      if name:
                          target_backend_names.append(name)

          target_backend_names = sorted(set(target_backend_names))

          if target_backend_names:
              backend_name_set = set(target_backend_names)
              for rule in rules:
                  backend_id = (rule.get("backendAddressPool") or {}).get("id")
                  if not backend_id:
                      continue
                  backend_name = backend_id.split('/')[-1]
                  if not backend_name or backend_name not in backend_name_set:
                      continue
                  rule_name = rule.get("name")
                  if rule_name:
                      target_rule_names.append(rule_name)
                      if backend_name:
                          rule_to_backend.setdefault(rule_name, backend_name)

          target_rule_names = sorted(set(target_rule_names))

          if not target_backend_names:
              print("Unable to identify backend pools associated with the ingress frontend", file=sys.stderr)
              sys.exit(1)

          if not target_rule_names:
              print("Unable to identify load balancing rules associated with the ingress frontend", file=sys.stderr)
              sys.exit(1)

          if github_env:
              with open(github_env, "a", encoding="utf-8") as env_file:
                  env_file.write(f"LB_NAME={lb_name}\n")
                  env_file.write(f"LB_FRONTEND_NAME={frontend_name}\n")
                  env_file.write("LB_TARGET_POOLS=" + " ".join(target_backend_names) + "\n")
                  env_file.write("LB_TARGET_RULES=" + " ".join(target_rule_names) + "\n")
                  if rule_to_backend:
                      env_file.write("LB_RULE_POOL_MAP=" + json.dumps(rule_to_backend, sort_keys=True) + "\n")

          print("Target backend pools:", ", ".join(target_backend_names))
          print("Target load balancing rules:", ", ".join(target_rule_names))
          
          summary = []
          for pool in lb.get("backendAddressPools") or []:
              name = pool.get("name") or "<unnamed>"
              count = len(pool.get("backendIpConfigurations") or [])
              summary.append((name, count))
          
          if summary:
              print("Backend pool membership:")
              for name, count in summary:
                  print(f"  {name}: {count} backend IP configuration(s)")
          else:
              print("No backend pools reported in load balancer resource")
          PY

      - name: Wait for Azure load balancer backends to become healthy
        shell: bash
        run: |
          set -euo pipefail

          if [ -z "${NODE_RESOURCE_GROUP:-}" ] || [ -z "${LB_NAME:-}" ] || [ -z "${LB_TARGET_POOLS:-}" ] || [ -z "${LB_TARGET_RULES:-}" ]; then
            echo "Missing load balancer context; ensure previous step succeeded." >&2
            exit 1
          fi

          python3 <<'PY'
          import json
          import os
          import subprocess
          import sys
          import time

          node_rg = os.environ.get("NODE_RESOURCE_GROUP", "").strip()
          lb_name = os.environ.get("LB_NAME", "").strip()
          pools = os.environ.get("LB_TARGET_POOLS", "").split()
          rules = os.environ.get("LB_TARGET_RULES", "").split()
          external_ip = os.environ.get("EXTERNAL_IP", "").strip()
          rule_pool_map_raw = os.environ.get("LB_RULE_POOL_MAP", "").strip()

          if not node_rg or not lb_name or not pools or not rules:
              print("Load balancer context is incomplete", file=sys.stderr)
              sys.exit(1)

          rule_pool_map = {}
          if rule_pool_map_raw:
              try:
                  rule_pool_map = json.loads(rule_pool_map_raw)
              except json.JSONDecodeError:
                  print("Warning: unable to parse LB_RULE_POOL_MAP; continuing without pool map", file=sys.stderr)

          subscription = os.environ.get("AZURE_SUBSCRIPTION_ID", "").strip()
          if not subscription:
              try:
                  subscription = subprocess.check_output([
                      "az",
                      "account",
                      "show",
                      "--query",
                      "id",
                      "-o",
                      "tsv",
                  ], text=True).strip()
              except subprocess.CalledProcessError as exc:
                  print(f"Failed to determine Azure subscription ID: {exc}", file=sys.stderr)
                  stderr = getattr(exc, "stderr", None)
                  stdout = getattr(exc, "output", None) or getattr(exc, "stdout", None)
                  if stderr:
                      print(stderr)
                  elif stdout:
                      print(stdout)
                  sys.exit(1)

          if not subscription:
              print("Azure subscription ID is unavailable", file=sys.stderr)
              sys.exit(1)

          api_version = "2024-05-01"

          def build_rule_label(rule: str) -> str:
              pool_name = rule_pool_map.get(rule)
              if pool_name:
                  return f"{rule} (pool {pool_name})"
              return rule

          def extract_nic_label(resource_id: str) -> str:
              if not resource_id:
                  return ""
              parts = [segment for segment in resource_id.split('/') if segment]
              nic_name = ""
              ipconfig_name = ""
              try:
                  nic_index = parts.index("networkInterfaces")
                  nic_name = parts[nic_index + 1]
              except (ValueError, IndexError):
                  nic_name = ""
              try:
                  ipconfig_index = parts.index("ipConfigurations")
                  ipconfig_name = parts[ipconfig_index + 1]
              except (ValueError, IndexError):
                  ipconfig_name = ""
              if nic_name and ipconfig_name:
                  return f"{nic_name}/{ipconfig_name}"
              return nic_name or ipconfig_name

          def query_rule_health(rule: str):
              url = (
                  f"https://management.azure.com/subscriptions/{subscription}/"
                  f"resourceGroups/{node_rg}/providers/Microsoft.Network/loadBalancers/{lb_name}/"
                  f"loadBalancingRules/{rule}/health?api-version={api_version}"
              )
              try:
                  result = subprocess.run(
                      [
                          "az",
                          "rest",
                          "--method",
                          "post",
                          "--url",
                          url,
                          "--only-show-errors",
                          "--output",
                          "json",
                      ],
                      check=True,
                      capture_output=True,
                      text=True,
                  )
              except subprocess.CalledProcessError as exc:
                  print(f"  Failed to query health for rule {rule}: {exc}", file=sys.stderr)
                  if exc.stderr:
                      print(exc.stderr)
                  elif exc.stdout:
                      print(exc.stdout)
                  return None

              output = (result.stdout or "").strip()
              if not output:
                  return {}

              try:
                  return json.loads(output)
              except json.JSONDecodeError:
                  print(f"  Received malformed JSON when querying rule {rule}", file=sys.stderr)
                  print(output)
                  return None

          max_attempts = 20
          sleep_seconds = 15

          for attempt in range(1, max_attempts + 1):
              print(
                  f"Checking load balancer backend health for {external_ip or '<unknown IP>'} "
                  f"(attempt {attempt}/{max_attempts})..."
              )
              any_up = False

              for rule in rules:
                  rule_label = build_rule_label(rule)
                  display_label = f"Rule {rule_label}"
                  data = query_rule_health(rule)
                  if data is None:
                      continue

                  backend_entries = data.get("loadBalancerBackendAddresses") or []
                  up_count = data.get("up")
                  down_count = data.get("down")

                  if not backend_entries:
                      if up_count is None and down_count is None:
                          print(f"  {display_label}: no backend addresses reported yet")
                      else:
                          print(
                              f"  {display_label}: up={up_count or 0} down={down_count or 0} "
                              "(no backend addresses reported yet)"
                          )
                      continue

                  for backend in backend_entries:
                      ip = backend.get("ipAddress") or "<unknown>"
                      state = backend.get("state") or "<unknown>"
                      reason = backend.get("reason")
                      nic_label = extract_nic_label(backend.get("networkInterfaceIPConfigurationId") or "")

                      backend_label = ip
                      if nic_label:
                          backend_label = f"{backend_label} [{nic_label}]"

                      message = f"  {display_label}: backend {backend_label} state={state}"
                      if reason:
                          message += f" (reason: {reason})"
                      print(message)

                      if state and state.lower() == "up":
                          any_up = True

              if any_up:
                  print("Azure reports at least one backend as healthy.")
                  break

              if attempt == max_attempts:
                  print("Azure never reported healthy backends within the allotted time", file=sys.stderr)
                  try:
                      summary = subprocess.check_output([
                          "az",
                          "network",
                          "lb",
                          "show",
                          "--resource-group",
                          node_rg,
                          "--name",
                          lb_name,
                          "--query",
                          "{name:name, provisioningState:provisioningState, frontend: frontendIPConfigurations[].{name:name, provisioningState:provisioningState, publicIpId:publicIpAddress.id}, backendPools: backendAddressPools[].{name:name, backendCount:length(backendIpConfigurations)}}",
                          "-o",
                          "json",
                      ], text=True)
                      print("Load balancer summary:")
                      print(summary)
                  except subprocess.CalledProcessError as exc:
                      print(f"Failed to retrieve load balancer summary: {exc}", file=sys.stderr)
                      if exc.output:
                          print(exc.output)
                  sys.exit(1)

              time.sleep(sleep_seconds)
          PY

      - name: Patch/Create midPoint Ingress
        env:
          NAMESPACE: ${{ inputs.NAMESPACE_IAM }}
        shell: bash
        run: |
          set -euo pipefail
          if ! kubectl -n "$NAMESPACE" get svc midpoint >/dev/null 2>&1; then
            echo "ERROR: Service midpoint not found in namespace ${NAMESPACE}."
            kubectl -n "$NAMESPACE" get svc || true
            exit 1
          fi
          if kubectl -n "$NAMESPACE" get ingress midpoint >/dev/null 2>&1; then
            echo "Reconciling existing midPoint Ingress host -> ${MP_HOST}"
          else
            echo "Creating midPoint Ingress with host ${MP_HOST}"
          fi
          kubectl -n "$NAMESPACE" create ingress midpoint \
            --class=nginx \
            --rule="${MP_HOST}/=midpoint:8080" \
            --annotation=nginx.ingress.kubernetes.io/proxy-body-size=16m \
            --dry-run=client \
            -o yaml \
            | kubectl apply -f -
          kubectl -n "$NAMESPACE" get ingress midpoint -o wide

      - name: Create/Update Keycloak Ingress (public)
        env:
          NAMESPACE: ${{ inputs.NAMESPACE_IAM }}
          SVC: ${{ inputs.KEYCLOAK_SERVICE_NAME }}
          PORT: ${{ inputs.KEYCLOAK_SERVICE_PORT }}
        shell: bash
        run: |
          set -euo pipefail
          if ! kubectl -n "$NAMESPACE" get svc "$SVC" >/dev/null 2>&1; then
            echo "ERROR: Service ${SVC} not found in namespace ${NAMESPACE}."
            kubectl -n "$NAMESPACE" get svc || true
            exit 1
          fi
          if ! kubectl -n "$NAMESPACE" get svc "$SVC" -o jsonpath='{range .spec.ports[*]}{.port}{"\n"}{end}' | grep -qx "$PORT"; then
            echo "ERROR: Service ${SVC} does not expose port ${PORT}."
            kubectl -n "$NAMESPACE" get svc "$SVC" -o yaml || true
            exit 1
          fi
          echo "Reconciling Keycloak public Ingress for host ${KC_HOST} -> ${SVC}:${PORT}"
          kubectl -n "$NAMESPACE" create ingress rws-keycloak-public \
            --class=nginx \
            --rule="${KC_HOST}/=${SVC}:${PORT}" \
            --annotation=nginx.ingress.kubernetes.io/proxy-body-size=16m \
            --dry-run=client \
            -o yaml \
            | kubectl apply -f -
          kubectl -n "$NAMESPACE" get ingress rws-keycloak-public -o wide

      - name: Smoke-test endpoints
        env:
          NAMESPACE: ${{ inputs.NAMESPACE_IAM }}
        shell: bash
        run: |
          set -euo pipefail
          echo "Keycloak:  http://${KC_HOST}"
          echo "midPoint:  http://${MP_HOST}/midpoint"
          attempts=18
          sleep_seconds=15
          for i in $(seq 1 "$attempts"); do
            echo "HTTP HEAD try ${i}/${attempts} ..."
            if curl -sS -I --fail --max-time 10 "http://${KC_HOST}" | head -n 1; then
              if curl -sS -I --fail --max-time 10 "http://${MP_HOST}/midpoint" | head -n 1; then
                echo "Endpoints responded successfully."
                break
              fi
            fi
            if [ "$i" -eq "$attempts" ]; then
              echo "ERROR: Endpoints did not respond successfully after ${attempts} attempts." >&2
              kubectl -n ingress-nginx get svc ingress-nginx-controller -o wide || true
              kubectl -n ingress-nginx get pods -l app.kubernetes.io/component=controller -o wide || true
              kubectl -n ingress-nginx get endpoints ingress-nginx-controller -o yaml || true
              kubectl -n "$NAMESPACE" get ingress midpoint rws-keycloak-public -o wide || true
              if [ -n "${NODE_RESOURCE_GROUP:-}" ] && [ -n "${LB_NAME:-}" ] && [ -n "${LB_TARGET_POOLS:-}" ] && [ -n "${LB_TARGET_RULES:-}" ]; then
                echo "Azure load balancer backend health (final observation):"
                python3 <<'PY'
          import json
          import os
          import subprocess
          import sys

          node_rg = os.environ.get("NODE_RESOURCE_GROUP", "").strip()
          lb_name = os.environ.get("LB_NAME", "").strip()
          pools = os.environ.get("LB_TARGET_POOLS", "").split()
          rules = os.environ.get("LB_TARGET_RULES", "").split()
          rule_pool_map_raw = os.environ.get("LB_RULE_POOL_MAP", "").strip()

          if not (node_rg and lb_name and pools and rules):
              print("Load balancer context missing; skipping Azure health dump.")
              sys.exit(0)

          rule_pool_map = {}
          if rule_pool_map_raw:
              try:
                  rule_pool_map = json.loads(rule_pool_map_raw)
              except json.JSONDecodeError:
                  print("Warning: unable to parse LB_RULE_POOL_MAP; continuing without pool map", file=sys.stderr)

          subscription = os.environ.get("AZURE_SUBSCRIPTION_ID", "").strip()
          if not subscription:
              try:
                  subscription = subprocess.check_output([
                      "az",
                      "account",
                      "show",
                      "--query",
                      "id",
                      "-o",
                      "tsv",
                  ], text=True).strip()
              except subprocess.CalledProcessError as exc:
                  print(f"Failed to determine Azure subscription ID: {exc}", file=sys.stderr)
                  stderr = getattr(exc, "stderr", None)
                  stdout = getattr(exc, "output", None) or getattr(exc, "stdout", None)
                  if stderr:
                      print(stderr)
                  elif stdout:
                      print(stdout)
                  sys.exit(0)

          if not subscription:
              print("Azure subscription ID is unavailable; skipping health dump.", file=sys.stderr)
              sys.exit(0)

          api_version = "2024-05-01"

          def build_rule_label(rule: str) -> str:
              pool_name = rule_pool_map.get(rule)
              if pool_name:
                  return f"{rule} (pool {pool_name})"
              return rule

          def extract_nic_label(resource_id: str) -> str:
              if not resource_id:
                  return ""
              parts = [segment for segment in resource_id.split('/') if segment]
              nic_name = ""
              ipconfig_name = ""
              try:
                  nic_index = parts.index("networkInterfaces")
                  nic_name = parts[nic_index + 1]
              except (ValueError, IndexError):
                  nic_name = ""
              try:
                  ipconfig_index = parts.index("ipConfigurations")
                  ipconfig_name = parts[ipconfig_index + 1]
              except (ValueError, IndexError):
                  ipconfig_name = ""
              if nic_name and ipconfig_name:
                  return f"{nic_name}/{ipconfig_name}"
              return nic_name or ipconfig_name

          def query_rule_health(rule: str):
              url = (
                  f"https://management.azure.com/subscriptions/{subscription}/"
                  f"resourceGroups/{node_rg}/providers/Microsoft.Network/loadBalancers/{lb_name}/"
                  f"loadBalancingRules/{rule}/health?api-version={api_version}"
              )
              try:
                  result = subprocess.run(
                      [
                          "az",
                          "rest",
                          "--method",
                          "post",
                          "--url",
                          url,
                          "--only-show-errors",
                          "--output",
                          "json",
                      ],
                      check=True,
                      capture_output=True,
                      text=True,
                  )
              except subprocess.CalledProcessError as exc:
                  print(f"Failed to query health for rule {rule}: {exc}", file=sys.stderr)
                  if exc.stderr:
                      print(exc.stderr)
                  elif exc.stdout:
                      print(exc.stdout)
                  return None

              output = (result.stdout or "").strip()
              if not output:
                  return {}

              try:
                  return json.loads(output)
              except json.JSONDecodeError:
                  print(f"Unexpected JSON for rule {rule}:")
                  print(output)
                  return None

          for rule in rules:
              rule_label = build_rule_label(rule)
              display_label = f"Rule {rule_label}"
              data = query_rule_health(rule)
              if data is None:
                  continue

              backend_entries = data.get("loadBalancerBackendAddresses") or []
              up_count = data.get("up")
              down_count = data.get("down")

              print(f"{display_label} summary: up={up_count or 0}, down={down_count or 0}")

              if not backend_entries:
                  print("  <no backend addresses>")
                  continue

              for backend in backend_entries:
                  ip = backend.get("ipAddress") or "<unknown>"
                  state = backend.get("state") or "<unknown>"
                  reason = backend.get("reason")
                  nic_label = extract_nic_label(backend.get("networkInterfaceIPConfigurationId") or "")

                  backend_label = ip
                  if nic_label:
                      backend_label = f"{backend_label} [{nic_label}]"

                  message = f"  {backend_label}: state={state}"
                  if reason:
                      message += f" (reason: {reason})"
                  print(message)
          PY
                if [ -n "${NODE_RESOURCE_GROUP:-}" ] && [ -n "${EXTERNAL_IP:-}" ]; then
                  echo "Azure public IP resource details:"
                  az network public-ip list \
                    --resource-group "$NODE_RESOURCE_GROUP" \
                    --query "[?ipAddress=='${EXTERNAL_IP}'].{name:name, ip:ipAddress, sku:sku.name, provisioningState:provisioningState}" \
                    -o table || true
                fi
              exit 1
            fi
            sleep "$sleep_seconds"
          done

      - name: Summary
        shell: bash
        run: |
          echo "✅ Done. Open these URLs in your browser:"
          echo "🔗 Keycloak : http://${KC_HOST}"
          echo "🔗 midPoint : http://${MP_HOST}/midpoint"
