name: "04 - Configure demo hosts (nip.io) & Ingresses"

on:
  workflow_dispatch:
    inputs:
      RESOURCE_GROUP:
        description: 'AKS Resource Group (from TF outputs)'
        required: true
        default: 'rwsdemo-rg'
      AKS_NAME:
        description: 'AKS cluster name (from TF outputs)'
        required: true
        default: 'rwsdemo-aks'
      NAMESPACE_IAM:
        description: 'Namespace for IAM stack (Keycloak + midPoint)'
        required: true
        default: 'iam'
      KEYCLOAK_SERVICE_NAME:
        description: 'Keycloak Service name (check kubectl -n <ns> get svc)'
        required: true
        default: 'rws-keycloak-service'
      KEYCLOAK_SERVICE_PORT:
        description: 'Keycloak Service port (8080 for httpEnabled=true)'
        required: true
        default: '8080'

permissions:
  id-token: write
  contents: read

jobs:
  configure:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get AKS credentials
        uses: azure/aks-set-context@v4
        with:
          resource-group: ${{ inputs.RESOURCE_GROUP }}
          cluster-name: ${{ inputs.AKS_NAME }}

      - name: Resolve EXTERNAL_IP for ingress-nginx LoadBalancer
        id: ip
        shell: bash
        run: |
          set -euo pipefail
          echo "Waiting for external IP of ingress-nginx LoadBalancer..."
          for i in {1..15}; do
            EXTERNAL_IP=$(kubectl -n ingress-nginx get svc ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}' || true)
            if [ -n "${EXTERNAL_IP:-}" ]; then break; fi
            echo "Attempt $i: no IP yet, retrying in 10s..."
            sleep 10
          done
          if [ -z "${EXTERNAL_IP:-}" ]; then
            HNAME=$(kubectl -n ingress-nginx get svc ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' || true)
            if [ -n "${HNAME:-}" ]; then
              if ! command -v dig >/dev/null 2>&1; then
                sudo apt-get update >/dev/null 2>&1 && sudo apt-get install -y dnsutils >/dev/null 2>&1
              fi
              EXTERNAL_IP=$(dig +short "$HNAME" | tail -n1 || true)
            fi
          fi
          if [ -z "${EXTERNAL_IP:-}" ]; then
            echo "ERROR: Could not determine external IP/hostname for ingress-nginx-controller."
            kubectl -n ingress-nginx get svc ingress-nginx-controller -o yaml || true
            exit 1
          fi
          KC_HOST="kc.${EXTERNAL_IP}.nip.io"
          MP_HOST="mp.${EXTERNAL_IP}.nip.io"
          echo "EXTERNAL_IP=$EXTERNAL_IP" | tee -a $GITHUB_ENV
          echo "KC_HOST=${KC_HOST}" | tee -a $GITHUB_ENV
          echo "MP_HOST=${MP_HOST}" | tee -a $GITHUB_ENV
          echo "keycloak_url=http://kc.${EXTERNAL_IP}.nip.io" >> $GITHUB_OUTPUT
          echo "midpoint_url=http://mp.${EXTERNAL_IP}.nip.io/midpoint" >> $GITHUB_OUTPUT
          echo "Resolved EXTERNAL_IP: $EXTERNAL_IP"
          echo "Keycloak host: $KC_HOST"
          echo "midPoint host: $MP_HOST"

      - name: Wait for ingress-nginx controller availability
        shell: bash
        run: |
          set -euo pipefail
          echo "Waiting for ingress-nginx controller deployment to become available..."
          kubectl -n ingress-nginx rollout status deploy/ingress-nginx-controller --timeout=600s

      - name: Identify Azure load balancer for ingress-nginx
        shell: bash
        env:
          RESOURCE_GROUP: ${{ inputs.RESOURCE_GROUP }}
          AKS_NAME: ${{ inputs.AKS_NAME }}
        run: |
          set -euo pipefail

          if ! command -v az >/dev/null 2>&1; then
            echo "Azure CLI not found on runner" >&2
            exit 1
          fi

          echo "Discovering AKS node resource group..."
          NODE_RG=$(az aks show -g "$RESOURCE_GROUP" -n "$AKS_NAME" --query nodeResourceGroup -o tsv)
          if [ -z "${NODE_RG:-}" ]; then
            echo "ERROR: Unable to determine AKS node resource group." >&2
            exit 1
          fi
          echo "NODE_RESOURCE_GROUP=${NODE_RG}" | tee -a "$GITHUB_ENV"
          export NODE_RESOURCE_GROUP="${NODE_RG}"

          python3 <<'PY'
          import datetime
          import email.utils
          import json
          import os
          import subprocess
          import sys
          import time
          import urllib.error
          import urllib.request
          
          external_ip = os.environ.get("EXTERNAL_IP", "").strip()
          node_rg = os.environ.get("NODE_RESOURCE_GROUP", "").strip()
          github_env = os.environ.get("GITHUB_ENV")
          
          if not external_ip:
              print("External IP not available in environment", file=sys.stderr)
              sys.exit(1)
          
          try:
              pip_raw = subprocess.check_output([
                  "az",
                  "network",
                  "public-ip",
                  "list",
                  "--resource-group",
                  node_rg,
                  "--query",
                  f"[?ipAddress=='{external_ip}']",
                  "-o",
                  "json",
              ], text=True)
          except subprocess.CalledProcessError as exc:
              print("Failed to list Azure public IPs:", exc, file=sys.stderr)
              sys.exit(1)
          
          try:
              pip_list = json.loads(pip_raw)
          except json.JSONDecodeError:
              print("Unable to parse Azure public IP list", file=sys.stderr)
              print(pip_raw)
              sys.exit(1)
          
          if not pip_list:
              print(f"No public IP resource in {node_rg!r} matches {external_ip}", file=sys.stderr)
              try:
                  inventory = subprocess.check_output([
                      "az",
                      "network",
                      "public-ip",
                      "list",
                      "--resource-group",
                      node_rg,
                      "--query",
                      "[].{name:name, ip:ipAddress, state:provisioningState}",
                      "-o",
                      "tsv",
                  ], text=True)
                  print("Existing public IPs (name\tip\tstate):")
                  print(inventory.strip() or "<none>")
              except subprocess.CalledProcessError as exc:
                  print("Additionally failed to enumerate all public IPs:", exc, file=sys.stderr)
              sys.exit(1)
          
          pip_entry = pip_list[0]
          ip_config = pip_entry.get("ipConfiguration")
          if isinstance(ip_config, dict):
              ip_config_ids = [ip_config.get("id")]
          elif isinstance(ip_config, list):
              ip_config_ids = [item.get("id") for item in ip_config if isinstance(item, dict)]
          else:
              ip_config_ids = []
          
          ip_config_ids = [item for item in ip_config_ids if item]
          if not ip_config_ids:
              print("The public IP is not attached to a load balancer frontend yet", file=sys.stderr)
              sys.exit(1)
          
          ip_config_id = ip_config_ids[0]
          parts = [segment for segment in ip_config_id.split('/') if segment]
          
          try:
              lb_index = parts.index("loadBalancers")
              frontend_index = parts.index("frontendIPConfigurations")
          except ValueError:
              print(f"Unexpected ipConfiguration id format: {ip_config_id}", file=sys.stderr)
              sys.exit(1)
          
          lb_name = parts[lb_index + 1]
          frontend_name = parts[frontend_index + 1]
          
          print(f"Resolved load balancer: {lb_name} (frontend {frontend_name})")
          
          try:
              lb_raw = subprocess.check_output([
                  "az",
                  "network",
                  "lb",
                  "show",
                  "--resource-group",
                  node_rg,
                  "--name",
                  lb_name,
                  "-o",
                  "json",
              ], text=True)
          except subprocess.CalledProcessError as exc:
              print("Failed to retrieve load balancer details:", exc, file=sys.stderr)
              sys.exit(1)
          
          lb = json.loads(lb_raw)
          rules = lb.get("loadBalancingRules") or []
          target_backend_names = []
          target_rule_names = []
          rule_to_backend = {}

          frontend_suffix = f"/frontendipconfigurations/{frontend_name}".lower()

          for rule in rules:
              frontend_id = (rule.get("frontendIPConfiguration") or {}).get("id", "")
              backend_id = (rule.get("backendAddressPool") or {}).get("id")
              if frontend_id.lower().endswith(frontend_suffix) and backend_id:
                  backend_name = backend_id.split('/')[-1]
                  if backend_name:
                      target_backend_names.append(backend_name)
                  rule_name = rule.get("name")
                  if rule_name:
                      target_rule_names.append(rule_name)
                      if backend_name:
                          rule_to_backend.setdefault(rule_name, backend_name)

          if not target_backend_names:
              # Fallback to all pools that currently reference any backend configs.
              for pool in lb.get("backendAddressPools") or []:
                  if pool.get("backendIpConfigurations"):
                      name = pool.get("name")
                      if name:
                          target_backend_names.append(name)

          target_backend_names = sorted(set(target_backend_names))

          if target_backend_names:
              backend_name_set = set(target_backend_names)
              for rule in rules:
                  backend_id = (rule.get("backendAddressPool") or {}).get("id")
                  if not backend_id:
                      continue
                  backend_name = backend_id.split('/')[-1]
                  if not backend_name or backend_name not in backend_name_set:
                      continue
                  rule_name = rule.get("name")
                  if rule_name:
                      target_rule_names.append(rule_name)
                      if backend_name:
                          rule_to_backend.setdefault(rule_name, backend_name)

          target_rule_names = sorted(set(target_rule_names))

          if not target_backend_names:
              print("Unable to identify backend pools associated with the ingress frontend", file=sys.stderr)
              sys.exit(1)

          if not target_rule_names:
              print("Unable to identify load balancing rules associated with the ingress frontend", file=sys.stderr)
              sys.exit(1)

          if github_env:
              with open(github_env, "a", encoding="utf-8") as env_file:
                  env_file.write(f"LB_NAME={lb_name}\n")
                  env_file.write(f"LB_FRONTEND_NAME={frontend_name}\n")
                  env_file.write("LB_TARGET_POOLS=" + " ".join(target_backend_names) + "\n")
                  env_file.write("LB_TARGET_RULES=" + " ".join(target_rule_names) + "\n")
                  if rule_to_backend:
                      env_file.write("LB_RULE_POOL_MAP=" + json.dumps(rule_to_backend, sort_keys=True) + "\n")

          print("Target backend pools:", ", ".join(target_backend_names))
          print("Target load balancing rules:", ", ".join(target_rule_names))
          
          summary = []
          for pool in lb.get("backendAddressPools") or []:
              name = pool.get("name") or "<unnamed>"
              count = len(pool.get("backendIpConfigurations") or [])
              summary.append((name, count))
          
          if summary:
              print("Backend pool membership:")
              for name, count in summary:
                  print(f"  {name}: {count} backend IP configuration(s)")
          else:
              print("No backend pools reported in load balancer resource")
          PY

      - name: Wait for Azure load balancer backends to become healthy
        shell: bash
        run: |
          set -euo pipefail

          if [ -z "${NODE_RESOURCE_GROUP:-}" ] || [ -z "${LB_NAME:-}" ] || [ -z "${LB_TARGET_POOLS:-}" ] || [ -z "${LB_TARGET_RULES:-}" ]; then
            echo "Missing load balancer context; ensure previous step succeeded." >&2
            exit 1
          fi

          python3 <<'PY'
          import datetime
          import email.utils
          import json
          import os
          import subprocess
          import sys
          import time
          import urllib.error
          import urllib.request

          node_rg = os.environ.get("NODE_RESOURCE_GROUP", "").strip()
          lb_name = os.environ.get("LB_NAME", "").strip()
          pools = os.environ.get("LB_TARGET_POOLS", "").split()
          rules = os.environ.get("LB_TARGET_RULES", "").split()
          external_ip = os.environ.get("EXTERNAL_IP", "").strip()
          rule_pool_map_raw = os.environ.get("LB_RULE_POOL_MAP", "").strip()

          if not node_rg or not lb_name or not pools or not rules:
              print("Load balancer context is incomplete", file=sys.stderr)
              sys.exit(1)

          rule_pool_map = {}
          if rule_pool_map_raw:
              try:
                  rule_pool_map = json.loads(rule_pool_map_raw)
              except json.JSONDecodeError:
                  print("Warning: unable to parse LB_RULE_POOL_MAP; continuing without pool map", file=sys.stderr)

          subscription = os.environ.get("AZURE_SUBSCRIPTION_ID", "").strip()
          if not subscription:
              try:
                  subscription = subprocess.check_output([
                      "az",
                      "account",
                      "show",
                      "--query",
                      "id",
                      "-o",
                      "tsv",
                  ], text=True).strip()
              except subprocess.CalledProcessError as exc:
                  print(f"Failed to determine Azure subscription ID: {exc}", file=sys.stderr)
                  stderr = getattr(exc, "stderr", None)
                  stdout = getattr(exc, "output", None) or getattr(exc, "stdout", None)
                  if stderr:
                      print(stderr)
                  elif stdout:
                      print(stdout)
                  sys.exit(1)

          if not subscription:
              print("Azure subscription ID is unavailable", file=sys.stderr)
              sys.exit(1)

          api_version = "2024-05-01"

          arm_resource = os.environ.get("ARM_RESOURCE", "").strip() or "https://management.azure.com/"
          token_cache = {"token": "", "expiry": 0.0}

          def _get_arm_token() -> str:
              now = time.time()
              cached_token = token_cache.get("token")
              cached_expiry = token_cache.get("expiry") or 0.0
              if cached_token and now < (cached_expiry - 60):
                  return cached_token

              try:
                  raw_output = subprocess.check_output(
                      [
                          "az",
                          "account",
                          "get-access-token",
                          "--resource",
                          arm_resource,
                          "--query",
                          "{accessToken:accessToken, expiresOn:expiresOn}",
                          "-o",
                          "json",
                      ],
                      text=True,
                  )
              except subprocess.CalledProcessError as exc:
                  print(f"  Failed to obtain Azure access token: {exc}", file=sys.stderr)
                  stderr = getattr(exc, "stderr", None)
                  stdout = getattr(exc, "output", None) or getattr(exc, "stdout", None)
                  if stderr:
                      print(stderr, file=sys.stderr)
                  elif stdout:
                      print(stdout, file=sys.stderr)
                  return ""

              token = ""
              try:
                  payload = json.loads(raw_output)
              except json.JSONDecodeError:
                  token = raw_output.strip()
              else:
                  token = (payload.get("accessToken") or "").strip()

              if not token:
                  print("  Received empty access token from Azure CLI.", file=sys.stderr)
                  return ""

              token_cache["token"] = token
              token_cache["expiry"] = now + 2400.0
              return token

          def _parse_retry_after(value: str) -> float:
              if not value:
                  return 0.0
              candidate = value.strip()
              if not candidate:
                  return 0.0
              if candidate.isdigit():
                  try:
                      seconds = float(candidate)
                  except ValueError:
                      return 0.0
                  return seconds if seconds > 0 else 0.0
              try:
                  parsed = email.utils.parsedate_to_datetime(candidate)
              except (TypeError, ValueError):
                  return 0.0
              if parsed is None:
                  return 0.0
              if parsed.tzinfo is None:
                  parsed = parsed.replace(tzinfo=datetime.timezone.utc)
              remaining = (
                  parsed - datetime.datetime.now(datetime.timezone.utc)
              ).total_seconds()
              return remaining if remaining > 0 else 0.0

          def _unwrap_operation_payload(payload):
              if isinstance(payload, dict):
                  status_value = payload.get("status")
                  if (
                      isinstance(status_value, str)
                      and status_value.lower() in {"succeeded", "failed", "canceled", "cancelled"}
                  ):
                      props = payload.get("properties")
                      if isinstance(props, dict):
                          for key in ("output", "outputs", "result", "value"):
                              if key in props and props[key] is not None:
                                  return _unwrap_operation_payload(props[key])
                          response = props.get("response")
                          if isinstance(response, dict):
                              body_payload = response.get("body")
                              if body_payload is not None:
                                  return _unwrap_operation_payload(body_payload)
                  props_value = payload.get("properties")
                  if isinstance(props_value, dict):
                      nested = _unwrap_operation_payload(props_value)
                      if nested is not None:
                          return nested
              return payload

          def _invoke_arm_json(method: str, url: str, description: str):
              method_upper = method.upper()

              def _send(request_method: str, request_url: str):
                  token = _get_arm_token()
                  if not token:
                      return 0, {}, None, ""

                  request = urllib.request.Request(request_url, method=request_method)
                  request.add_header("Authorization", f"Bearer {token}")

                  if request_method in {"POST", "PUT", "PATCH"}:
                      request.data = b""
                      request.add_header("Content-Length", "0")

                  try:
                      with urllib.request.urlopen(request, timeout=60) as response:
                          status_code = getattr(response, "status", response.getcode())
                          headers = {k.lower(): v for k, v in response.headers.items()}
                          body_bytes = response.read()
                  except urllib.error.HTTPError as exc:
                      status_code = exc.code
                      headers = {k.lower(): v for k, v in exc.headers.items()} if exc.headers else {}
                      body_bytes = exc.read()

                  body_text = body_bytes.decode("utf-8", errors="replace") if body_bytes else ""
                  payload = None
                  if body_text:
                      try:
                          payload = json.loads(body_text)
                      except json.JSONDecodeError:
                          payload = None
                  return status_code, headers, payload, body_text

              status_code, headers, payload, raw_text = _send(method_upper, url)
              if status_code in (200, 201):
                  if isinstance(payload, dict):
                      return _unwrap_operation_payload(payload)
                  return payload

              if status_code == 202:
                  location = headers.get("location") or headers.get("operation-location")
                  if not location:
                      return _unwrap_operation_payload(payload) if isinstance(payload, dict) else payload

                  wait_seconds = _parse_retry_after(headers.get("retry-after"))
                  if wait_seconds <= 0:
                      wait_seconds = 5.0

                  last_payload = payload
                  last_text = raw_text

                  for poll_attempt in range(12):
                      if poll_attempt or wait_seconds > 0:
                          time.sleep(wait_seconds)

                      poll_status, poll_headers, poll_payload, poll_text = _send("GET", location)
                      if poll_status in (200, 201):
                          if isinstance(poll_payload, dict):
                              return _unwrap_operation_payload(poll_payload)
                          return poll_payload

                      if poll_status == 202:
                          wait_seconds = (
                              _parse_retry_after(poll_headers.get("retry-after"))
                              or wait_seconds
                              or 5.0
                          )
                          last_payload = poll_payload
                          last_text = poll_text
                          continue

                      if poll_status == 204:
                          return {}

                      if poll_status >= 400:
                          if description:
                              print(
                                  f"  Polling {description} failed with status {poll_status}",
                                  file=sys.stderr,
                              )
                          else:
                              print(
                                  f"  Polling Azure operation failed with status {poll_status}",
                                  file=sys.stderr,
                              )
                          if poll_text:
                              print(poll_text, file=sys.stderr)
                          return None

                      last_payload = poll_payload
                      last_text = poll_text

                  if description:
                      print(f"  Timed out waiting for {description}", file=sys.stderr)
                  else:
                      print("  Timed out waiting for Azure operation to complete", file=sys.stderr)

                  if isinstance(last_payload, dict):
                      return _unwrap_operation_payload(last_payload)
                  if last_text:
                      print(last_text, file=sys.stderr)
                  return last_payload

              if status_code == 204:
                  return {}

              if status_code >= 400:
                  if description:
                      print(
                          f"  ARM request for {description} failed with status {status_code}",
                          file=sys.stderr,
                      )
                  else:
                      print(
                          f"  ARM request failed with status {status_code}",
                          file=sys.stderr,
                      )
                  if raw_text:
                      print(raw_text, file=sys.stderr)
                  return None

              if isinstance(payload, dict):
                  return _unwrap_operation_payload(payload)
              return payload

          def build_rule_label(rule: str) -> str:
              pool_name = rule_pool_map.get(rule)
              if pool_name:
                  return f"{rule} (pool {pool_name})"
              return rule

          def extract_nic_label(resource_id: str) -> str:
              if not resource_id:
                  return ""
              parts = [segment for segment in resource_id.split('/') if segment]
              nic_name = ""
              ipconfig_name = ""
              try:
                  nic_index = parts.index("networkInterfaces")
                  nic_name = parts[nic_index + 1]
              except (ValueError, IndexError):
                  nic_name = ""
              try:
                  ipconfig_index = parts.index("ipConfigurations")
                  ipconfig_name = parts[ipconfig_index + 1]
              except (ValueError, IndexError):
                  ipconfig_name = ""
              if nic_name and ipconfig_name:
                  return f"{nic_name}/{ipconfig_name}"
              return nic_name or ipconfig_name

          def parse_count(value):
              if isinstance(value, int):
                  return value
              if isinstance(value, str):
                  stripped = value.strip()
                  if stripped.isdigit():
                      return int(stripped)
              return None

          def interpret_state(state: str) -> str:
              if not state:
                  return "unknown"
              normalized = state.strip().lower()
              if normalized in {"up", "healthy", "inservice", "succeeded", "success", "available", "ok"}:
                  return "up"
              if normalized in {"down", "unhealthy", "drain", "outofservice", "failed", "failure"}:
                  return "down"
              return "unknown"

          def _get_first_string(source, keys):
              for key in keys:
                  value = source.get(key)
                  if isinstance(value, str):
                      stripped = value.strip()
                      if stripped:
                          return stripped
              return ""

          def normalise_backend_entry(entry):
              if not isinstance(entry, dict):
                  return None
              aggregated = {
                  "ip": "",
                  "state": "",
                  "reason": "",
                  "nic_id": "",
                  "pool_id": "",
                  "name": entry.get("name") if isinstance(entry.get("name"), str) else "",
              }

              def _update_from_backend_address(source):
                  if not isinstance(source, dict):
                      return

                  name_value = source.get("name")
                  if isinstance(name_value, str) and name_value.strip():
                      if not aggregated["name"]:
                          aggregated["name"] = name_value.strip()

                  aggregated["ip"] = aggregated["ip"] or _get_first_string(
                      source,
                      (
                          "ipAddress",
                          "ipaddress",
                          "ip",
                          "frontendIPAddress",
                          "frontendIpAddress",
                          "privateIPAddress",
                          "privateIpAddress",
                          "address",
                      ),
                  )

                  aggregated["nic_id"] = aggregated["nic_id"] or _get_first_string(
                      source,
                      (
                          "networkInterfaceIPConfigurationId",
                          "networkInterfaceId",
                          "ipConfigurationId",
                          "resourceId",
                      ),
                  )

                  aggregated["pool_id"] = aggregated["pool_id"] or _get_first_string(
                      source,
                      (
                          "backendAddressPoolId",
                          "backendPoolId",
                          "poolId",
                      ),
                  )

                  backend_address_props = source.get("properties")
                  if isinstance(backend_address_props, dict):
                      _update_from_backend_address(backend_address_props)

              candidates = [entry]
              props = entry.get("properties")
              if isinstance(props, dict):
                  candidates.append(props)
              for candidate in candidates:
                  aggregated["ip"] = aggregated["ip"] or _get_first_string(candidate, (
                      "ipAddress",
                      "ipaddress",
                      "ip",
                      "frontendIPAddress",
                      "frontendIpAddress",
                      "fqdn",
                      "fullyQualifiedDomainName",
                      "privateIPAddress",
                      "privateIpAddress",
                  ))
                  aggregated["state"] = aggregated["state"] or _get_first_string(candidate, (
                      "state",
                      "status",
                      "health",
                      "healthStatus",
                      "healthState",
                  ))
                  aggregated["reason"] = aggregated["reason"] or _get_first_string(candidate, (
                      "reason",
                      "details",
                      "detail",
                      "description",
                      "healthProbeStatus",
                  ))
                  aggregated["nic_id"] = aggregated["nic_id"] or _get_first_string(candidate, (
                      "networkInterfaceIPConfigurationId",
                      "backendIPConfigurationId",
                  ))
                  aggregated["pool_id"] = aggregated["pool_id"] or _get_first_string(candidate, (
                      "backendAddressPoolId",
                  ))
                  backend_ip_config = candidate.get("backendIPConfiguration")
                  if isinstance(backend_ip_config, dict) and not aggregated["nic_id"]:
                      nic_value = backend_ip_config.get("id")
                      if isinstance(nic_value, str) and nic_value.strip():
                          aggregated["nic_id"] = nic_value.strip()
                  backend_pool = candidate.get("backendAddressPool")
                  if isinstance(backend_pool, dict) and not aggregated["pool_id"]:
                      pool_value = backend_pool.get("id")
                      if isinstance(pool_value, str) and pool_value.strip():
                          aggregated["pool_id"] = pool_value.strip()
                  backend_address = candidate.get("backendAddress")
                  if isinstance(backend_address, dict):
                      _update_from_backend_address(backend_address)
                  backend_address_health = candidate.get("backendAddressHealth")
                  if isinstance(backend_address_health, dict):
                      _update_from_backend_address(backend_address_health)
              aggregated["state"] = aggregated["state"].strip()
              if not aggregated["state"]:
                  return None
              aggregated["name"] = aggregated["name"].strip()
              if not aggregated["ip"] and not aggregated["nic_id"] and not aggregated["name"]:
                  return None
              return aggregated

          def extract_backend_entries(data):
              if data is None:
                  return []
              results = []
              seen_entries = set()
              seen_nodes = set()

              def enqueue(value, stack):
                  if isinstance(value, (dict, list)) and id(value) not in seen_nodes:
                      stack.append(value)

              stack = []
              enqueue(data, stack)

              while stack:
                  node = stack.pop()
                  node_id = id(node)
                  if node_id in seen_nodes:
                      continue
                  seen_nodes.add(node_id)

                  if isinstance(node, dict):
                      entry = normalise_backend_entry(node)
                      if entry:
                          key = (
                              entry.get("ip") or "",
                              entry.get("nic_id") or "",
                              entry.get("state") or "",
                              entry.get("pool_id") or "",
                          )
                          if key not in seen_entries:
                              seen_entries.add(key)
                              results.append(entry)
                      for key_name in (
                          "loadBalancerBackendAddresses",
                          "loadBalancerBackendAddressHealths",
                          "backendAddressHealths",
                          "backendAddresses",
                          "value",
                      ):
                          enqueue(node.get(key_name), stack)
                      enqueue(node.get("properties"), stack)
                      for value in node.values():
                          enqueue(value, stack)
                  elif isinstance(node, list):
                      for item in node:
                          enqueue(item, stack)

              return results

          def summarise_states(entries):
              summary = {"up": 0, "down": 0, "unknown": 0}
              for entry in entries:
                  category = interpret_state(entry.get("state"))
                  summary[category] = summary.get(category, 0) + 1
              return summary

          def extract_pool_name(pool_id: str) -> str:
              if not pool_id:
                  return ""
              parts = [segment for segment in pool_id.split('/') if segment]
              if not parts:
                  return ""
              return parts[-1]

          def query_rule_health(rule: str):
              url = (
                  f"https://management.azure.com/subscriptions/{subscription}/"
                  f"resourceGroups/{node_rg}/providers/Microsoft.Network/loadBalancers/{lb_name}/"
                  f"loadBalancingRules/{rule}/health?api-version={api_version}"
              )
              description = f"load balancer rule {rule} health"
              result = _invoke_arm_json("POST", url, description)
              if isinstance(result, dict):
                  return result
              return {}

          max_attempts = 20
          sleep_seconds = 15

          for attempt in range(1, max_attempts + 1):
              print(
                  f"Checking load balancer backend health for {external_ip or '<unknown IP>'} "
                  f"(attempt {attempt}/{max_attempts})..."
              )
              any_up = False

              for rule in rules:
                  rule_label = build_rule_label(rule)
                  display_label = f"Rule {rule_label}"
                  data = query_rule_health(rule)
                  if data is None:
                      continue

                  backend_entries = extract_backend_entries(data)
                  summary_counts = summarise_states(backend_entries)

                  up_count = parse_count(data.get("up"))
                  down_count = parse_count(data.get("down"))
                  unknown_count = parse_count(data.get("unknown"))

                  if up_count is None:
                      up_count = summary_counts["up"]
                  if down_count is None:
                      down_count = summary_counts["down"]
                  if unknown_count is None:
                      unknown_count = summary_counts.get("unknown", 0)

                  status_text = ""
                  for candidate_key in ("status", "provisioningState"):
                      value = data.get(candidate_key)
                      if isinstance(value, str) and value.strip():
                          status_text = value.strip()
                          break

                  detail_text = ""
                  for candidate_key in ("details", "detail", "message", "reason"):
                      value = data.get(candidate_key)
                      if isinstance(value, str) and value.strip():
                          detail_text = value.strip()
                          break

                  rule_has_up = up_count > 0

                  if not backend_entries:
                      if up_count or down_count or unknown_count:
                          summary = f"  {display_label}: up={up_count} down={down_count}"
                          if unknown_count:
                              summary += f" unknown={unknown_count}"
                          summary += " (no backend addresses reported yet)"
                          message_parts = [summary]
                      else:
                          message_parts = [f"  {display_label}: no backend addresses reported yet"]
                      if status_text:
                          message_parts.append(f"status={status_text}")
                      if detail_text:
                          message_parts.append(detail_text)
                      print(" ".join(message_parts))
                      if up_count:
                          rule_has_up = True
                      if rule_has_up:
                          any_up = True
                      continue

                  summary_line = f"  {display_label}: up={up_count} down={down_count}"
                  if unknown_count:
                      summary_line += f" unknown={unknown_count}"
                  if status_text:
                      summary_line += f" status={status_text}"
                  print(summary_line)

                  for entry in backend_entries:
                      backend_label = entry.get("ip") or entry.get("name") or "<unknown>"
                      nic_label = extract_nic_label(entry.get("nic_id", "")) or ""
                      if nic_label:
                          backend_label = f"{backend_label} [{nic_label}]"
                      pool_name = extract_pool_name(entry.get("pool_id", "")) or ""
                      state_text = entry.get("state") or "<unknown>"
                      reason_text = entry.get("reason") or ""
                      detail_components = []
                      if pool_name:
                          detail_components.append(f"pool {pool_name}")
                      if reason_text:
                          detail_components.append(f"reason: {reason_text}")
                      detail_suffix = ""
                      if detail_components:
                          detail_suffix = " (" + ", ".join(detail_components) + ")"
                      print(f"  {display_label}: backend {backend_label} state={state_text}{detail_suffix}")
                      if interpret_state(state_text) == "up":
                          rule_has_up = True

                  if summary_counts.get("up", 0) > 0:
                      rule_has_up = True

                  if rule_has_up:
                      any_up = True

              if any_up:
                  print("Azure reports at least one backend as healthy.")
                  break

              if attempt == max_attempts:
                  print("Azure never reported healthy backends within the allotted time", file=sys.stderr)
                  try:
                      lb_raw = subprocess.check_output(
                          [
                              "az",
                              "network",
                              "lb",
                              "show",
                              "--resource-group",
                              node_rg,
                              "--name",
                              lb_name,
                              "-o",
                              "json",
                          ],
                          text=True,
                      )
                  except subprocess.CalledProcessError as exc:
                      print(f"Failed to retrieve load balancer summary: {exc}", file=sys.stderr)
                      stderr = getattr(exc, "stderr", None)
                      stdout = getattr(exc, "output", None) or getattr(exc, "stdout", None)
                      if stderr:
                          print(stderr)
                      elif stdout:
                          print(stdout)
                  else:
                      try:
                          lb_info = json.loads(lb_raw)
                      except json.JSONDecodeError:
                          print("Received malformed load balancer JSON:", file=sys.stderr)
                          print(lb_raw)
                      else:
                          if not isinstance(lb_info, dict):
                              print("Unexpected load balancer payload; expected an object.", file=sys.stderr)
                          else:
                              def _provisioning_state(resource):
                                  if isinstance(resource, dict):
                                      value = resource.get("provisioningState")
                                      if isinstance(value, str):
                                          return value
                                      props = resource.get("properties")
                                      if isinstance(props, dict):
                                          value = props.get("provisioningState")
                                          if isinstance(value, str):
                                              return value
                                  return ""

                              def _public_ip_id(frontend):
                                  if not isinstance(frontend, dict):
                                      return ""
                                  candidates = []
                                  for key_name in ("publicIPAddress", "publicIpAddress"):
                                      candidates.append(frontend.get(key_name))
                                  props = frontend.get("properties")
                                  if isinstance(props, dict):
                                      for key_name in ("publicIPAddress", "publicIpAddress"):
                                          candidates.append(props.get(key_name))
                                  for candidate in candidates:
                                      if isinstance(candidate, dict):
                                          value = candidate.get("id")
                                          if isinstance(value, str):
                                              return value
                                  return ""

                              def _backend_configs(pool):
                                  if not isinstance(pool, dict):
                                      return []
                                  candidates = [
                                      pool.get("backendIpConfigurations"),
                                      pool.get("backendIPConfigurations"),
                                  ]
                                  props = pool.get("properties")
                                  if isinstance(props, dict):
                                      candidates.append(props.get("backendIpConfigurations"))
                                      candidates.append(props.get("backendIPConfigurations"))
                                  for candidate in candidates:
                                      if isinstance(candidate, list):
                                          return candidate
                                  return []

                              frontends = []
                              for frontend in lb_info.get("frontendIPConfigurations") or []:
                                  name = frontend.get("name") if isinstance(frontend, dict) else None
                                  frontends.append(
                                      {
                                          "name": name or "<unnamed>",
                                          "provisioningState": _provisioning_state(frontend) or "",
                                          "publicIpId": _public_ip_id(frontend) or "",
                                      }
                                  )

                              backend_pools = []
                              for pool in lb_info.get("backendAddressPools") or []:
                                  name = pool.get("name") if isinstance(pool, dict) else None
                                  backend_pools.append(
                                      {
                                          "name": name or "<unnamed>",
                                          "backendCount": len(_backend_configs(pool)),
                                      }
                                  )

                              summary = {
                                  "name": lb_info.get("name"),
                                  "provisioningState": _provisioning_state(lb_info),
                                  "frontend": frontends,
                                  "backendPools": backend_pools,
                              }

                              print("Load balancer summary:")
                              print(json.dumps(summary, indent=2, sort_keys=True))
                  sys.exit(1)

              time.sleep(sleep_seconds)
          PY


      - name: Patch/Create midPoint Ingress
        env:
          NAMESPACE: ${{ inputs.NAMESPACE_IAM }}
        shell: bash
        run: |
          set -euo pipefail
          if ! kubectl -n "$NAMESPACE" get svc midpoint >/dev/null 2>&1; then
            echo "ERROR: Service midpoint not found in namespace ${NAMESPACE}."
            kubectl -n "$NAMESPACE" get svc || true
            exit 1
          fi
          if kubectl -n "$NAMESPACE" get ingress midpoint >/dev/null 2>&1; then
            echo "Reconciling existing midPoint Ingress host -> ${MP_HOST}"
          else
            echo "Creating midPoint Ingress with host ${MP_HOST}"
          fi
          kubectl -n "$NAMESPACE" create ingress midpoint \
            --class=nginx \
            --rule="${MP_HOST}/=midpoint:8080" \
            --annotation=nginx.ingress.kubernetes.io/proxy-body-size=16m \
            --dry-run=client \
            -o yaml \
            | kubectl apply -f -
          kubectl -n "$NAMESPACE" get ingress midpoint -o wide

      - name: Create/Update Keycloak Ingress (public)
        env:
          NAMESPACE: ${{ inputs.NAMESPACE_IAM }}
          SVC: ${{ inputs.KEYCLOAK_SERVICE_NAME }}
          PORT: ${{ inputs.KEYCLOAK_SERVICE_PORT }}
        shell: bash
        run: |
          set -euo pipefail
          if ! kubectl -n "$NAMESPACE" get svc "$SVC" >/dev/null 2>&1; then
            echo "ERROR: Service ${SVC} not found in namespace ${NAMESPACE}."
            kubectl -n "$NAMESPACE" get svc || true
            exit 1
          fi
          if ! kubectl -n "$NAMESPACE" get svc "$SVC" -o jsonpath='{range .spec.ports[*]}{.port}{"\n"}{end}' | grep -qx "$PORT"; then
            echo "ERROR: Service ${SVC} does not expose port ${PORT}."
            kubectl -n "$NAMESPACE" get svc "$SVC" -o yaml || true
            exit 1
          fi
          echo "Reconciling Keycloak public Ingress for host ${KC_HOST} -> ${SVC}:${PORT}"
          kubectl -n "$NAMESPACE" create ingress rws-keycloak-public \
            --class=nginx \
            --rule="${KC_HOST}/=${SVC}:${PORT}" \
            --annotation=nginx.ingress.kubernetes.io/proxy-body-size=16m \
            --dry-run=client \
            -o yaml \
            | kubectl apply -f -
          kubectl -n "$NAMESPACE" get ingress rws-keycloak-public -o wide

      - name: Smoke-test endpoints
        env:
          NAMESPACE: ${{ inputs.NAMESPACE_IAM }}
        shell: bash
        run: |
          set -euo pipefail

          : "${KC_HOST:?KC_HOST environment variable not set}"
          : "${MP_HOST:?MP_HOST environment variable not set}"

          echo "Keycloak:  http://${KC_HOST}"
          echo "midPoint:  http://${MP_HOST}/midpoint"

          check_endpoint() {
            local label="$1"
            shift
            local url=""
            local status=1
            local curl_exit=0
            for url in "$@"; do
              [ -n "${url}" ] || continue
              echo "  -> Probing ${label} via ${url}"
              if curl -sS --fail --location --max-time 15 -o /dev/null -D - "${url}" | head -n 1; then
                echo "  ${label} responded via ${url}"
                status=0
                break
              else
                curl_exit=$?
                echo "  ${label} request to ${url} did not succeed (exit code ${curl_exit}); retrying..." >&2
              fi
            done
            return "${status}"
          }

          attempts=18
          sleep_seconds=15

          keycloak_urls=(
            "http://${KC_HOST}"
            "http://${KC_HOST}/realms/master"
            "http://${KC_HOST}/realms/master/.well-known/openid-configuration"
          )

          midpoint_urls=(
            "http://${MP_HOST}/midpoint/"
            "http://${MP_HOST}/midpoint"
            "http://${MP_HOST}"
          )

          for i in $(seq 1 "${attempts}"); do
            echo "HTTP availability try ${i}/${attempts} ..."
            if check_endpoint "Keycloak" "${keycloak_urls[@]}" && \
               check_endpoint "midPoint" "${midpoint_urls[@]}"; then
              echo "Endpoints responded successfully."
              break
            fi
            if [ "${i}" -eq "${attempts}" ]; then
              echo "ERROR: Endpoints did not respond successfully after ${attempts} attempts." >&2
              kubectl -n ingress-nginx get svc ingress-nginx-controller -o wide || true
              kubectl -n ingress-nginx get pods -l app.kubernetes.io/component=controller -o wide || true
              kubectl -n ingress-nginx get endpoints ingress-nginx-controller -o yaml || true
              kubectl -n "${NAMESPACE}" get ingress midpoint rws-keycloak-public -o wide || true
              if [ -n "${NODE_RESOURCE_GROUP:-}" ] && [ -n "${LB_NAME:-}" ] && [ -n "${LB_TARGET_POOLS:-}" ] && [ -n "${LB_TARGET_RULES:-}" ]; then
                echo "Azure load balancer backend health (final observation):"
                python3 <<'PY'
          import datetime
          import email.utils
          import json
          import os
          import subprocess
          import sys
          import time
          import urllib.error
          import urllib.request

          node_rg = os.environ.get("NODE_RESOURCE_GROUP", "").strip()
          lb_name = os.environ.get("LB_NAME", "").strip()
          pools = os.environ.get("LB_TARGET_POOLS", "").split()
          rules = os.environ.get("LB_TARGET_RULES", "").split()
          rule_pool_map_raw = os.environ.get("LB_RULE_POOL_MAP", "").strip()

          if not (node_rg and lb_name and pools and rules):
              print("Load balancer context missing; skipping Azure health dump.")
              sys.exit(0)

          rule_pool_map = {}
          if rule_pool_map_raw:
              try:
                  rule_pool_map = json.loads(rule_pool_map_raw)
              except json.JSONDecodeError:
                  print("Warning: unable to parse LB_RULE_POOL_MAP; continuing without pool map", file=sys.stderr)

          subscription = os.environ.get("AZURE_SUBSCRIPTION_ID", "").strip()
          if not subscription:
              try:
                  subscription = subprocess.check_output([
                      "az",
                      "account",
                      "show",
                      "--query",
                      "id",
                      "-o",
                      "tsv",
                  ], text=True).strip()
              except subprocess.CalledProcessError as exc:
                  print(f"Failed to determine Azure subscription ID: {exc}", file=sys.stderr)
                  stderr = getattr(exc, "stderr", None)
                  stdout = getattr(exc, "output", None) or getattr(exc, "stdout", None)
                  if stderr:
                      print(stderr)
                  elif stdout:
                      print(stdout)
                  sys.exit(0)

          if not subscription:
              print("Azure subscription ID is unavailable; skipping health dump.", file=sys.stderr)
              sys.exit(0)

          api_version = "2024-05-01"

          arm_resource = os.environ.get("ARM_RESOURCE", "").strip() or "https://management.azure.com/"
          token_cache = {"token": "", "expiry": 0.0}

          def _get_arm_token() -> str:
              now = time.time()
              cached_token = token_cache.get("token")
              cached_expiry = token_cache.get("expiry") or 0.0
              if cached_token and now < (cached_expiry - 60):
                  return cached_token

              try:
                  raw_output = subprocess.check_output(
                      [
                          "az",
                          "account",
                          "get-access-token",
                          "--resource",
                          arm_resource,
                          "--query",
                          "{accessToken:accessToken, expiresOn:expiresOn}",
                          "-o",
                          "json",
                      ],
                      text=True,
                  )
              except subprocess.CalledProcessError as exc:
                  print(f"  Failed to obtain Azure access token: {exc}", file=sys.stderr)
                  stderr = getattr(exc, "stderr", None)
                  stdout = getattr(exc, "output", None) or getattr(exc, "stdout", None)
                  if stderr:
                      print(stderr, file=sys.stderr)
                  elif stdout:
                      print(stdout, file=sys.stderr)
                  return ""

              token = ""
              try:
                  payload = json.loads(raw_output)
              except json.JSONDecodeError:
                  token = raw_output.strip()
              else:
                  token = (payload.get("accessToken") or "").strip()

              if not token:
                  print("  Received empty access token from Azure CLI.", file=sys.stderr)
                  return ""

              token_cache["token"] = token
              token_cache["expiry"] = now + 2400.0
              return token

          def _parse_retry_after(value: str) -> float:
              if not value:
                  return 0.0
              candidate = value.strip()
              if not candidate:
                  return 0.0
              if candidate.isdigit():
                  try:
                      seconds = float(candidate)
                  except ValueError:
                      return 0.0
                  return seconds if seconds > 0 else 0.0
              try:
                  parsed = email.utils.parsedate_to_datetime(candidate)
              except (TypeError, ValueError):
                  return 0.0
              if parsed is None:
                  return 0.0
              if parsed.tzinfo is None:
                  parsed = parsed.replace(tzinfo=datetime.timezone.utc)
              remaining = (
                  parsed - datetime.datetime.now(datetime.timezone.utc)
              ).total_seconds()
              return remaining if remaining > 0 else 0.0

          def _unwrap_operation_payload(payload):
              if isinstance(payload, dict):
                  status_value = payload.get("status")
                  if (
                      isinstance(status_value, str)
                      and status_value.lower() in {"succeeded", "failed", "canceled", "cancelled"}
                  ):
                      props = payload.get("properties")
                      if isinstance(props, dict):
                          for key in ("output", "outputs", "result", "value"):
                              if key in props and props[key] is not None:
                                  return _unwrap_operation_payload(props[key])
                          response = props.get("response")
                          if isinstance(response, dict):
                              body_payload = response.get("body")
                              if body_payload is not None:
                                  return _unwrap_operation_payload(body_payload)
                  props_value = payload.get("properties")
                  if isinstance(props_value, dict):
                      nested = _unwrap_operation_payload(props_value)
                      if nested is not None:
                          return nested
              return payload

          def _invoke_arm_json(method: str, url: str, description: str):
              method_upper = method.upper()

              def _send(request_method: str, request_url: str):
                  token = _get_arm_token()
                  if not token:
                      return 0, {}, None, ""

                  request = urllib.request.Request(request_url, method=request_method)
                  request.add_header("Authorization", f"Bearer {token}")

                  if request_method in {"POST", "PUT", "PATCH"}:
                      request.data = b""
                      request.add_header("Content-Length", "0")

                  try:
                      with urllib.request.urlopen(request, timeout=60) as response:
                          status_code = getattr(response, "status", response.getcode())
                          headers = {k.lower(): v for k, v in response.headers.items()}
                          body_bytes = response.read()
                  except urllib.error.HTTPError as exc:
                      status_code = exc.code
                      headers = {k.lower(): v for k, v in exc.headers.items()} if exc.headers else {}
                      body_bytes = exc.read()

                  body_text = body_bytes.decode("utf-8", errors="replace") if body_bytes else ""
                  payload = None
                  if body_text:
                      try:
                          payload = json.loads(body_text)
                      except json.JSONDecodeError:
                          payload = None
                  return status_code, headers, payload, body_text

              status_code, headers, payload, raw_text = _send(method_upper, url)
              if status_code in (200, 201):
                  if isinstance(payload, dict):
                      return _unwrap_operation_payload(payload)
                  return payload

              if status_code == 202:
                  location = headers.get("location") or headers.get("operation-location")
                  if not location:
                      return _unwrap_operation_payload(payload) if isinstance(payload, dict) else payload

                  wait_seconds = _parse_retry_after(headers.get("retry-after"))
                  if wait_seconds <= 0:
                      wait_seconds = 5.0

                  last_payload = payload
                  last_text = raw_text

                  for poll_attempt in range(12):
                      if poll_attempt or wait_seconds > 0:
                          time.sleep(wait_seconds)

                      poll_status, poll_headers, poll_payload, poll_text = _send("GET", location)
                      if poll_status in (200, 201):
                          if isinstance(poll_payload, dict):
                              return _unwrap_operation_payload(poll_payload)
                          return poll_payload

                      if poll_status == 202:
                          wait_seconds = (
                              _parse_retry_after(poll_headers.get("retry-after"))
                              or wait_seconds
                              or 5.0
                          )
                          last_payload = poll_payload
                          last_text = poll_text
                          continue

                      if poll_status == 204:
                          return {}

                      if poll_status >= 400:
                          if description:
                              print(
                                  f"  Polling {description} failed with status {poll_status}",
                                  file=sys.stderr,
                              )
                          else:
                              print(
                                  f"  Polling Azure operation failed with status {poll_status}",
                                  file=sys.stderr,
                              )
                          if poll_text:
                              print(poll_text, file=sys.stderr)
                          return None

                      last_payload = poll_payload
                      last_text = poll_text

                  if description:
                      print(f"  Timed out waiting for {description}", file=sys.stderr)
                  else:
                      print("  Timed out waiting for Azure operation to complete", file=sys.stderr)

                  if isinstance(last_payload, dict):
                      return _unwrap_operation_payload(last_payload)
                  if last_text:
                      print(last_text, file=sys.stderr)
                  return last_payload

              if status_code == 204:
                  return {}

              if status_code >= 400:
                  if description:
                      print(
                          f"  ARM request for {description} failed with status {status_code}",
                          file=sys.stderr,
                      )
                  else:
                      print(
                          f"  ARM request failed with status {status_code}",
                          file=sys.stderr,
                      )
                  if raw_text:
                      print(raw_text, file=sys.stderr)
                  return None

              if isinstance(payload, dict):
                  return _unwrap_operation_payload(payload)
              return payload

          def build_rule_label(rule: str) -> str:
              pool_name = rule_pool_map.get(rule)
              if pool_name:
                  return f"{rule} (pool {pool_name})"
              return rule

          def extract_nic_label(resource_id: str) -> str:
              if not resource_id:
                  return ""
              parts = [segment for segment in resource_id.split('/') if segment]
              nic_name = ""
              ipconfig_name = ""
              try:
                  nic_index = parts.index("networkInterfaces")
                  nic_name = parts[nic_index + 1]
              except (ValueError, IndexError):
                  nic_name = ""
              try:
                  ipconfig_index = parts.index("ipConfigurations")
                  ipconfig_name = parts[ipconfig_index + 1]
              except (ValueError, IndexError):
                  ipconfig_name = ""
              if nic_name and ipconfig_name:
                  return f"{nic_name}/{ipconfig_name}"
              return nic_name or ipconfig_name

          def parse_count(value):
              if isinstance(value, int):
                  return value
              if isinstance(value, str):
                  stripped = value.strip()
                  if stripped.isdigit():
                      return int(stripped)
              return None

          def interpret_state(state: str) -> str:
              if not state:
                  return "unknown"
              normalized = state.strip().lower()
              if normalized in {"up", "healthy", "inservice", "succeeded", "success", "available", "ok"}:
                  return "up"
              if normalized in {"down", "unhealthy", "drain", "outofservice", "failed", "failure"}:
                  return "down"
              return "unknown"

          def _get_first_string(source, keys):
              for key in keys:
                  value = source.get(key)
                  if isinstance(value, str):
                      stripped = value.strip()
                      if stripped:
                          return stripped
              return ""

          def normalise_backend_entry(entry):
              if not isinstance(entry, dict):
                  return None
              aggregated = {
                  "ip": "",
                  "state": "",
                  "reason": "",
                  "nic_id": "",
                  "pool_id": "",
                  "name": entry.get("name") if isinstance(entry.get("name"), str) else "",
              }

              def _update_from_backend_address(source):
                  if not isinstance(source, dict):
                      return

                  name_value = source.get("name")
                  if isinstance(name_value, str) and name_value.strip():
                      if not aggregated["name"]:
                          aggregated["name"] = name_value.strip()

                  aggregated["ip"] = aggregated["ip"] or _get_first_string(
                      source,
                      (
                          "ipAddress",
                          "ipaddress",
                          "ip",
                          "frontendIPAddress",
                          "frontendIpAddress",
                          "privateIPAddress",
                          "privateIpAddress",
                          "address",
                      ),
                  )

                  aggregated["nic_id"] = aggregated["nic_id"] or _get_first_string(
                      source,
                      (
                          "networkInterfaceIPConfigurationId",
                          "networkInterfaceId",
                          "ipConfigurationId",
                          "resourceId",
                      ),
                  )

                  aggregated["pool_id"] = aggregated["pool_id"] or _get_first_string(
                      source,
                      (
                          "backendAddressPoolId",
                          "backendPoolId",
                          "poolId",
                      ),
                  )

                  backend_address_props = source.get("properties")
                  if isinstance(backend_address_props, dict):
                      _update_from_backend_address(backend_address_props)

              candidates = [entry]
              props = entry.get("properties")
              if isinstance(props, dict):
                  candidates.append(props)
              for candidate in candidates:
                  aggregated["ip"] = aggregated["ip"] or _get_first_string(candidate, (
                      "ipAddress",
                      "ipaddress",
                      "ip",
                      "frontendIPAddress",
                      "frontendIpAddress",
                      "fqdn",
                      "fullyQualifiedDomainName",
                      "privateIPAddress",
                      "privateIpAddress",
                  ))
                  aggregated["state"] = aggregated["state"] or _get_first_string(candidate, (
                      "state",
                      "status",
                      "health",
                      "healthStatus",
                      "healthState",
                  ))
                  aggregated["reason"] = aggregated["reason"] or _get_first_string(candidate, (
                      "reason",
                      "details",
                      "detail",
                      "description",
                      "healthProbeStatus",
                  ))
                  aggregated["nic_id"] = aggregated["nic_id"] or _get_first_string(candidate, (
                      "networkInterfaceIPConfigurationId",
                      "backendIPConfigurationId",
                  ))
                  aggregated["pool_id"] = aggregated["pool_id"] or _get_first_string(candidate, (
                      "backendAddressPoolId",
                  ))
                  backend_ip_config = candidate.get("backendIPConfiguration")
                  if isinstance(backend_ip_config, dict) and not aggregated["nic_id"]:
                      nic_value = backend_ip_config.get("id")
                      if isinstance(nic_value, str) and nic_value.strip():
                          aggregated["nic_id"] = nic_value.strip()
                  backend_pool = candidate.get("backendAddressPool")
                  if isinstance(backend_pool, dict) and not aggregated["pool_id"]:
                      pool_value = backend_pool.get("id")
                      if isinstance(pool_value, str) and pool_value.strip():
                          aggregated["pool_id"] = pool_value.strip()
                  backend_address = candidate.get("backendAddress")
                  if isinstance(backend_address, dict):
                      _update_from_backend_address(backend_address)
                  backend_address_health = candidate.get("backendAddressHealth")
                  if isinstance(backend_address_health, dict):
                      _update_from_backend_address(backend_address_health)
              aggregated["state"] = aggregated["state"].strip()
              if not aggregated["state"]:
                  return None
              aggregated["name"] = aggregated["name"].strip()
              if not aggregated["ip"] and not aggregated["nic_id"] and not aggregated["name"]:
                  return None
              return aggregated

          def extract_backend_entries(data):
              if data is None:
                  return []
              results = []
              seen_entries = set()
              seen_nodes = set()

              def enqueue(value, stack):
                  if isinstance(value, (dict, list)) and id(value) not in seen_nodes:
                      stack.append(value)

              stack = []
              enqueue(data, stack)

              while stack:
                  node = stack.pop()
                  node_id = id(node)
                  if node_id in seen_nodes:
                      continue
                  seen_nodes.add(node_id)

                  if isinstance(node, dict):
                      entry = normalise_backend_entry(node)
                      if entry:
                          key = (
                              entry.get("ip") or "",
                              entry.get("nic_id") or "",
                              entry.get("state") or "",
                              entry.get("pool_id") or "",
                          )
                          if key not in seen_entries:
                              seen_entries.add(key)
                              results.append(entry)
                      for key_name in (
                          "loadBalancerBackendAddresses",
                          "loadBalancerBackendAddressHealths",
                          "backendAddressHealths",
                          "backendAddresses",
                          "value",
                      ):
                          enqueue(node.get(key_name), stack)
                      enqueue(node.get("properties"), stack)
                      for value in node.values():
                          enqueue(value, stack)
                  elif isinstance(node, list):
                      for item in node:
                          enqueue(item, stack)

              return results

          def summarise_states(entries):
              summary = {"up": 0, "down": 0, "unknown": 0}
              for entry in entries:
                  category = interpret_state(entry.get("state"))
                  summary[category] = summary.get(category, 0) + 1
              return summary

          def extract_pool_name(pool_id: str) -> str:
              if not pool_id:
                  return ""
              parts = [segment for segment in pool_id.split('/') if segment]
              if not parts:
                  return ""
              return parts[-1]

          def query_rule_health(rule: str):
              url = (
                  f"https://management.azure.com/subscriptions/{subscription}/"
                  f"resourceGroups/{node_rg}/providers/Microsoft.Network/loadBalancers/{lb_name}/"
                  f"loadBalancingRules/{rule}/health?api-version={api_version}"
              )
              description = f"load balancer rule {rule} health"
              result = _invoke_arm_json("POST", url, description)
              if isinstance(result, dict):
                  return result
              return {}

          for rule in rules:
              rule_label = build_rule_label(rule)
              display_label = f"Rule {rule_label}"
              data = query_rule_health(rule)
              if data is None:
                  continue

              backend_entries = extract_backend_entries(data)
              summary_counts = summarise_states(backend_entries)

              up_count = parse_count(data.get("up"))
              down_count = parse_count(data.get("down"))
              unknown_count = parse_count(data.get("unknown"))

              if up_count is None:
                  up_count = summary_counts["up"]
              if down_count is None:
                  down_count = summary_counts["down"]
              if unknown_count is None:
                  unknown_count = summary_counts.get("unknown", 0)

              status_text = ""
              for candidate_key in ("status", "provisioningState"):
                  value = data.get(candidate_key)
                  if isinstance(value, str) and value.strip():
                      status_text = value.strip()
                      break

              detail_text = ""
              for candidate_key in ("details", "detail", "message", "reason"):
                  value = data.get(candidate_key)
                  if isinstance(value, str) and value.strip():
                      detail_text = value.strip()
                      break

              summary_line = f"{display_label} summary: up={up_count} down={down_count}"
              if unknown_count:
                  summary_line += f" unknown={unknown_count}"
              if status_text:
                  summary_line += f" status={status_text}"
              print(summary_line)

              if detail_text:
                  print(f"  details: {detail_text}")

              if not backend_entries:
                  print("  <no backend addresses>")
                  continue

              for entry in backend_entries:
                  backend_label = entry.get("ip") or entry.get("name") or "<unknown>"
                  nic_label = extract_nic_label(entry.get("nic_id", "")) or ""
                  if nic_label:
                      backend_label = f"{backend_label} [{nic_label}]"
                  pool_name = extract_pool_name(entry.get("pool_id", "")) or ""
                  state_text = entry.get("state") or "<unknown>"
                  reason_text = entry.get("reason") or ""
                  detail_components = []
                  if pool_name:
                      detail_components.append(f"pool {pool_name}")
                  if reason_text:
                      detail_components.append(f"reason: {reason_text}")
                  detail_suffix = ""
                  if detail_components:
                      detail_suffix = " (" + ", ".join(detail_components) + ")"
                  print(f"  {backend_label}: state={state_text}{detail_suffix}")
          PY

                if [ -n "${NODE_RESOURCE_GROUP:-}" ] && [ -n "${EXTERNAL_IP:-}" ]; then
                  echo "Azure public IP resource details:"
                  az network public-ip list \
                    --resource-group "$NODE_RESOURCE_GROUP" \
                    --query "[?ipAddress=='${EXTERNAL_IP}'].{name:name, ip:ipAddress, sku:sku.name, provisioningState:provisioningState}" \
                    -o table || true
                fi
              fi
              exit 1
            fi
            sleep "$sleep_seconds"
          done

      - name: Summary
        shell: bash
        run: |
          echo "✅ Done. Open these URLs in your browser:"
          echo "🔗 Keycloak : http://${KC_HOST}"
          echo "🔗 midPoint : http://${MP_HOST}/midpoint"
