name: 02 - Bootstrap ArgoCD, Addons, DB, Keycloak, midPoint

on:
  workflow_dispatch:
    inputs:
      LOCATION:
        description: 'Azure region'
        required: false
        default: 'westeurope'
      RESOURCE_GROUP:
        description: 'Resource Group name (output of TF)'
        required: true
        default: 'rwsdemo-rg'
      AKS_NAME:
        description: 'AKS cluster name (output of TF)'
        required: true
        default: 'rwsdemo-aks'
      STORAGE_ACCOUNT:
        description: 'Azure Storage Account name for CNPG backups (output of TF)'
        required: true
      NAMESPACE_IAM:
        description: 'Namespace for IAM stack (Keycloak + midPoint + DB)'
        required: false
        default: 'iam'

permissions:
  id-token: write
  contents: read

jobs:
  bootstrap:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get AKS credentials
        uses: azure/aks-set-context@v4
        with:
          resource-group: ${{ inputs.RESOURCE_GROUP }}
          cluster-name: ${{ inputs.AKS_NAME }}

      - name: Create namespaces
        run: |
          kubectl create ns argocd --dry-run=client -o yaml | kubectl apply -f -
          kubectl create ns ingress-nginx --dry-run=client -o yaml | kubectl apply -f -
          kubectl create ns cert-manager --dry-run=client -o yaml | kubectl apply -f -
          kubectl create ns cnpg-system --dry-run=client -o yaml | kubectl apply -f -
          kubectl create ns ${{ inputs.NAMESPACE_IAM }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Install Argo CD (stable manifest)
        run: |
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
          echo "Waiting for Argo CD core components to become ready..."
          for workload in deploy/argocd-server deploy/argocd-repo-server deploy/argocd-redis deploy/argocd-dex-server; do
            echo "Waiting for rollout of ${workload}"
            kubectl -n argocd rollout status "$workload" --timeout=300s
          done
          echo "Waiting for Argo CD application controller statefulset"
          kubectl -n argocd rollout status statefulset/argocd-application-controller --timeout=300s

      - name: Sync addons via Argo (Ingress-NGINX, cert-manager, CNPG operator)
        run: |
          export REPO_OWNER="${GITHUB_REPOSITORY%%/*}"
          export REPO_NAME="${GITHUB_REPOSITORY##*/}"
          envsubst < k8s/argocd/root-apps.yaml | kubectl apply -f -
          echo "Waiting for Argo CD application 'addons' to be created and synced"
          addons_ready=0
          for attempt in $(seq 1 60); do
            if kubectl -n argocd get application addons >/dev/null 2>&1; then
              sync_status=$(kubectl -n argocd get application addons -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "")
              health_status=$(kubectl -n argocd get application addons -o jsonpath='{.status.health.status}' 2>/dev/null || echo "")
              if [ "$sync_status" = "Synced" ] && [ "$health_status" = "Healthy" ]; then
                echo "addons application is synced and healthy"
                addons_ready=1
                break
              fi
              echo "addons application status: sync=${sync_status:-<unknown>} health=${health_status:-<unknown>} (attempt ${attempt}/60)"
            else
              echo "addons application not found yet (attempt ${attempt}/60)"
            fi
            sleep 10
          done
          if [ "$addons_ready" -ne 1 ]; then
            echo "Timed out waiting for addons application to become healthy"
            kubectl -n argocd get application addons -o yaml || true
            exit 1
          fi
          kubectl -n argocd get application addons

      - name: Wait for cnpg-operator Argo CD application
        run: |
          echo "Waiting for Argo CD application cnpg-operator to be created..."
          for attempt in $(seq 1 60); do
            if kubectl -n argocd get application cnpg-operator >/dev/null 2>&1; then
              sync_status=$(kubectl -n argocd get application cnpg-operator -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "")
              health_status=$(kubectl -n argocd get application cnpg-operator -o jsonpath='{.status.health.status}' 2>/dev/null || echo "")
              if [ "$sync_status" = "Synced" ] && [ "$health_status" = "Healthy" ]; then
                echo "cnpg-operator application is synced and healthy"
                exit 0
              fi
              echo "cnpg-operator status: sync=${sync_status:-<unknown>} health=${health_status:-<unknown>} (attempt ${attempt}/60)"
            else
              echo "Application cnpg-operator not found yet (attempt ${attempt}/60)"
            fi
            sleep 10
          done
          echo "Timed out waiting for cnpg-operator Argo CD application to become healthy"
          kubectl -n argocd get application cnpg-operator -o yaml || true
          exit 1

      - name: Wait for CNPG operator CRDs
        run: |
          echo "Waiting for CloudNativePG CRDs to become available..."
          for attempt in $(seq 1 30); do
            if kubectl get crd clusters.postgresql.cnpg.io >/dev/null 2>&1; then
              if kubectl wait --for=condition=Established crd/clusters.postgresql.cnpg.io --timeout=60s; then
                if kubectl -n cnpg-system get deployment cnpg-cloudnative-pg >/dev/null 2>&1; then
                  if kubectl -n cnpg-system wait --for=condition=Available deployment/cnpg-cloudnative-pg --timeout=300s; then
                    echo "CloudNativePG operator deployment is available"
                    exit 0
                  else
                    echo "Deployment cnpg-cloudnative-pg exists but is not yet available (attempt ${attempt}/30)"
                  fi
                else
                  echo "Deployment cnpg-cloudnative-pg not found yet (attempt ${attempt}/30)"
                fi
              else
                echo "CRD clusters.postgresql.cnpg.io exists but is not yet established (attempt ${attempt}/30)"
              fi
            else
              echo "CRD clusters.postgresql.cnpg.io not found yet (attempt ${attempt}/30)"
            fi
            sleep 10
          done
          echo "Timed out waiting for CloudNativePG CRDs"
          exit 1

      - name: Wait for CNPG webhook service endpoints
        run: |
          echo "Ensuring cnpg-webhook-service has ready endpoints..."
          for attempt in $(seq 1 30); do
            if kubectl -n cnpg-system get endpoints cnpg-webhook-service >/dev/null 2>&1; then
              ready_endpoints=$(kubectl -n cnpg-system get endpoints cnpg-webhook-service -o jsonpath='{range .subsets[*].addresses[*]}{.ip} {end}' 2>/dev/null)
              if [ -n "${ready_endpoints}" ]; then
                echo "cnpg-webhook-service has ready endpoints: ${ready_endpoints}"
                exit 0
              fi
              not_ready_endpoints=$(kubectl -n cnpg-system get endpoints cnpg-webhook-service -o jsonpath='{range .subsets[*].notReadyAddresses[*]}{.ip} {end}' 2>/dev/null)
              echo "cnpg-webhook-service found but endpoints are not ready yet (attempt ${attempt}/30). NotReady: ${not_ready_endpoints:-none}"
            else
              echo "cnpg-webhook-service not created yet (attempt ${attempt}/30)"
            fi
            sleep 10
          done
          echo "Timed out waiting for cnpg-webhook-service endpoints"
          kubectl -n cnpg-system get pods -l app.kubernetes.io/instance=cnpg -o wide || true
          kubectl -n cnpg-system get endpoints cnpg-webhook-service -o yaml || true
          exit 1

      - name: Create CNPG secrets (DB users + superuser)
        run: |
          kubectl -n ${{ inputs.NAMESPACE_IAM }} create secret generic cnpg-superuser \
            --from-literal=password='${{ secrets.POSTGRES_SUPERUSER_PASSWORD }}' \
            --dry-run=client -o yaml | kubectl apply -f -

          kubectl -n ${{ inputs.NAMESPACE_IAM }} create secret generic keycloak-db-app \
            --from-literal=username='keycloak' \
            --from-literal=password='${{ secrets.KEYCLOAK_DB_PASSWORD }}' \
            --dry-run=client -o yaml | kubectl apply -f -

          kubectl -n ${{ inputs.NAMESPACE_IAM }} create secret generic midpoint-db-app \
            --from-literal=username='midpoint' \
            --from-literal=password='${{ secrets.MIDPOINT_DB_PASSWORD }}' \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Create Azure Blob secret for CNPG backups (connection string or key)
        env:
          AZURE_STORAGE_ACCOUNT: ${{ inputs.STORAGE_ACCOUNT }}
          AZURE_STORAGE_KEY: ${{ secrets.AZURE_STORAGE_KEY }}
        run: |
          if [ -z "$AZURE_STORAGE_KEY" ]; then
            echo "AZURE_STORAGE_KEY secret is required for demo backup. Add it in repo secrets."
            exit 1
          fi
          kubectl -n ${{ inputs.NAMESPACE_IAM }} create secret generic cnpg-azure-backup \
            --from-literal=AZURE_STORAGE_ACCOUNT="$AZURE_STORAGE_ACCOUNT" \
            --from-literal=AZURE_STORAGE_KEY="$AZURE_STORAGE_KEY" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Validate CNPG prerequisites
        env:
          NAMESPACE_IAM: ${{ inputs.NAMESPACE_IAM }}
        shell: bash
        run: |
          set -euo pipefail

          ns="${NAMESPACE_IAM}"
          echo "Checking required database secrets exist in namespace ${ns}"
          missing=0
          for secret in cnpg-superuser keycloak-db-app midpoint-db-app cnpg-azure-backup; do
            if ! kubectl -n "${ns}" get secret "${secret}" >/dev/null 2>&1; then
              echo "ERROR: secret ${secret} is missing from namespace ${ns}"
              missing=1
            fi
          done

          if [ "${missing}" -ne 0 ]; then
            echo "One or more required secrets are missing; aborting."
            exit 1
          fi

          check_secret_key() {
            local secret="$1"
            local key="$2"
            local value
            value=$(kubectl -n "${ns}" get secret "${secret}" -o jsonpath="{.data.${key}}" 2>/dev/null || true)
            if [ -z "${value}" ]; then
              echo "ERROR: secret ${secret} does not contain key ${key}"
              missing=1
            fi
          }

          check_secret_key cnpg-superuser password
          check_secret_key keycloak-db-app username
          check_secret_key keycloak-db-app password
          check_secret_key midpoint-db-app username
          check_secret_key midpoint-db-app password
          check_secret_key cnpg-azure-backup AZURE_STORAGE_ACCOUNT
          check_secret_key cnpg-azure-backup AZURE_STORAGE_KEY

          if [ "${missing}" -ne 0 ]; then
            echo "Secret validation failed; aborting."
            exit 1
          fi

          echo "Confirming CNPG operator deployment readiness"
          kubectl -n cnpg-system get deployment cnpg-cloudnative-pg
          if ! kubectl -n cnpg-system rollout status deployment/cnpg-cloudnative-pg --timeout=180s; then
            echo "WARNING: cnpg-cloudnative-pg deployment not yet available"
          fi

          echo "Inspecting CNPG webhook service endpoints"
          if ! kubectl -n cnpg-system get service cnpg-webhook-service >/dev/null 2>&1; then
            echo "ERROR: cnpg-webhook-service not found in cnpg-system namespace"
            exit 1
          fi

          ready_endpoints=$(kubectl -n cnpg-system get endpoints cnpg-webhook-service -o jsonpath='{range .subsets[*].addresses[*]}{.ip} {end}' 2>/dev/null || true)
          if [ -z "${ready_endpoints}" ]; then
            echo "ERROR: cnpg-webhook-service currently has no ready endpoints"
            kubectl -n cnpg-system get endpoints cnpg-webhook-service -o yaml || true
            exit 1
          fi

          echo "cnpg-webhook-service ready endpoints: ${ready_endpoints}"

      - name: Apply CNPG cluster (iam-db)
        env:
          STORAGE_ACCOUNT: ${{ inputs.STORAGE_ACCOUNT }}
          NAMESPACE_IAM: ${{ inputs.NAMESPACE_IAM }}
        shell: bash
        run: |
          set -euo pipefail

          manifest="$(mktemp)"
          trap 'rm -f "${manifest}"' EXIT
          sed "s/{{STORAGE_ACCOUNT}}/${STORAGE_ACCOUNT}/g" k8s/apps/cnpg/cluster.yaml > "${manifest}"

          max_attempts=5
          for attempt in $(seq 1 "${max_attempts}"); do
            echo "Applying CNPG cluster manifest (attempt ${attempt}/${max_attempts})"

            prereqs_ready=1
            if ! kubectl -n cnpg-system rollout status deployment/cnpg-cloudnative-pg --timeout=180s; then
              echo "cnpg-cloudnative-pg deployment not yet available"
              prereqs_ready=0
            fi

            if ! kubectl -n cnpg-system wait --for=condition=Ready pod -l app.kubernetes.io/name=cloudnative-pg --timeout=180s; then
              echo "CNPG operator pods are not yet in Ready state"
              prereqs_ready=0
            fi

            ready_endpoints=$(kubectl -n cnpg-system get endpoints cnpg-webhook-service -o jsonpath='{range .subsets[*].addresses[*]}{.ip} {end}' 2>/dev/null || true)
            if [ -z "${ready_endpoints}" ]; then
              echo "cnpg-webhook-service has no ready endpoints before attempt ${attempt}"
              kubectl -n cnpg-system get endpoints cnpg-webhook-service -o yaml || true
              prereqs_ready=0
            else
              echo "cnpg-webhook-service endpoints: ${ready_endpoints}"
            fi

            if [ "${prereqs_ready}" -ne 1 ]; then
              echo "CNPG operator prerequisites are not ready, waiting before retrying"
              sleep 20
              continue
            fi

            if kubectl apply -f "${manifest}"; then
              echo "CNPG cluster manifest applied successfully"
              success=1
              break
            fi

            echo "kubectl apply failed on attempt ${attempt}; showing CNPG operator diagnostics"
            kubectl -n cnpg-system get pods -l app.kubernetes.io/name=cloudnative-pg -o wide || true
            kubectl -n cnpg-system describe deployment cnpg-cloudnative-pg || true
            kubectl -n cnpg-system get endpoints cnpg-webhook-service -o yaml || true
            sleep 20
          done

          if [ "${success:-0}" -ne 1 ]; then
            echo "Failed to apply CNPG cluster manifest after ${max_attempts} attempts"
            exit 1
          fi

          kubectl -n "${NAMESPACE_IAM}" wait cluster/iam-db --for=condition=Ready --timeout=600s || true

      - name: Install Keycloak Operator (CRDs + operator Deployment)
        run: |
          kubectl apply -f https://raw.githubusercontent.com/keycloak/keycloak-k8s-resources/26.3.4/kubernetes/keycloaks.k8s.keycloak.org-v1.yml
          kubectl apply -f https://raw.githubusercontent.com/keycloak/keycloak-k8s-resources/26.3.4/kubernetes/keycloakrealmimports.k8s.keycloak.org-v1.yml
          kubectl apply -f https://raw.githubusercontent.com/keycloak/keycloak-k8s-resources/26.3.4/kubernetes/kubernetes.yml

      - name: Prepare midPoint config and admin secret
        env:
          MIDPOINT_ADMIN_PASSWORD: ${{ secrets.MIDPOINT_ADMIN_PASSWORD }}
        run: |
          kubectl -n ${{ inputs.NAMESPACE_IAM }} create secret generic midpoint-admin \
            --from-literal=password="$MIDPOINT_ADMIN_PASSWORD" \
            --dry-run=client -o yaml | kubectl apply -f -
          kubectl -n ${{ inputs.NAMESPACE_IAM }} create configmap midpoint-config \
            --from-file=config.xml=k8s/apps/midpoint/config.xml \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Wait for Keycloak operator CRDs
        run: |
          echo "Waiting for Keycloak CRDs to become available..."
          for crd in keycloaks.k8s.keycloak.org keycloakrealmimports.k8s.keycloak.org; do
            kubectl wait --for=condition=Established crd/${crd} --timeout=300s
          done
          for ns in keycloak-system keycloak default; do
            if kubectl -n "$ns" get deployment keycloak-operator >/dev/null 2>&1; then
              kubectl -n "$ns" wait --for=condition=Available deployment/keycloak-operator --timeout=300s || true
              break
            fi
          done

      - name: Create Argo CD application for iam apps (Keycloak + midPoint)
        run: |
          export REPO_OWNER="${GITHUB_REPOSITORY%%/*}"
          export REPO_NAME="${GITHUB_REPOSITORY##*/}"
          envsubst < k8s/argocd/apps.yaml | kubectl apply -f -

      - name: Wait for iam apps Argo CD application
        run: |
          kubectl -n argocd wait --for=condition=Synced applications/apps --timeout=600s
          kubectl -n argocd wait --for=condition=Healthy applications/apps --timeout=600s || true

      - name: Show ingress endpoints (if available)
        run: |
          echo "Ingress-NGINX service:"
          kubectl -n ingress-nginx get svc ingress-nginx-controller -o wide || true
          echo "Keycloak service:"
          kubectl -n ${{ inputs.NAMESPACE_IAM }} get svc rws-keycloak -o wide || true
          echo "midPoint service:"
          kubectl -n ${{ inputs.NAMESPACE_IAM }} get svc midpoint -o wide || true
