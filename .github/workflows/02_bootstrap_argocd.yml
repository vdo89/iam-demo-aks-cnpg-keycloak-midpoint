name: 02 - Bootstrap GitOps stack

on:
  workflow_dispatch:
    inputs:
      RESOURCE_GROUP:
        description: 'Resource Group name (Terraform output)'
        required: true
        default: 'rwsdemo-rg'
      AKS_NAME:
        description: 'AKS cluster name (Terraform output)'
        required: true
        default: 'rwsdemo-aks'
      STORAGE_ACCOUNT:
        description: 'Azure Storage Account name for CNPG backups (Terraform output)'
        required: true
      NAMESPACE_IAM:
        description: 'Namespace for IAM workloads (Keycloak + midPoint + CNPG)'
        required: false
        default: 'iam'

permissions:
  id-token: write
  contents: read

jobs:
  bootstrap:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get AKS credentials
        uses: azure/aks-set-context@v4
        with:
          resource-group: ${{ inputs.RESOURCE_GROUP }}
          cluster-name: ${{ inputs.AKS_NAME }}

      - name: Install Argo CD (kustomize bootstrap)
        shell: bash
        run: |
          set -euo pipefail
          kubectl apply -k gitops/clusters/aks/bootstrap
          echo "Waiting for Argo CD control plane to become ready"
          for workload in \
            deploy/argocd-server \
            deploy/argocd-repo-server \
            deploy/argocd-redis \
            deploy/argocd-dex-server; do
            echo "Waiting for rollout of ${workload}"
            kubectl -n argocd rollout status "${workload}" --timeout=300s
          done
          kubectl -n argocd rollout status statefulset/argocd-application-controller --timeout=300s

      - name: Configure Argo CD repository credentials (private repos only)
        if: ${{ secrets.ARGOCD_REPO_USERNAME != '' && secrets.ARGOCD_REPO_TOKEN != '' }}
        shell: bash
        env:
          GITHUB_REPOSITORY: ${{ github.repository }}
          ARGOCD_REPO_USERNAME: ${{ secrets.ARGOCD_REPO_USERNAME }}
          ARGOCD_REPO_TOKEN: ${{ secrets.ARGOCD_REPO_TOKEN }}
        run: |
          set -euo pipefail
          owner="${GITHUB_REPOSITORY%%/*}"
          repo="${GITHUB_REPOSITORY##*/}"
          sanitized=$(printf '%s' "${owner}-${repo}" | tr '[:upper:]' '[:lower:]' | tr -c 'a-z0-9' '-' | sed 's/^-*//;s/-*$//')
          secret_name="repo-${sanitized:-repo}"
          kubectl -n argocd create secret generic "${secret_name}" \
            --type=Opaque \
            --from-literal=url="https://github.com/${owner}/${repo}" \
            --from-literal=username="${ARGOCD_REPO_USERNAME}" \
            --from-literal=password="${ARGOCD_REPO_TOKEN}" \
            --dry-run=client -o yaml | kubectl apply -f -
          kubectl -n argocd label secret "${secret_name}" argocd.argoproj.io/secret-type=repository --overwrite

      - name: Validate CNPG storage account configuration
        shell: bash
        env:
          STORAGE_ACCOUNT_INPUT: ${{ inputs.STORAGE_ACCOUNT }}
        run: |
          set -euo pipefail
          config_file="gitops/apps/iam/cnpg/params.env"
          if [ ! -f "${config_file}" ]; then
            echo "${config_file} is missing. Commit it with the Terraform storage account output before running this workflow."
            exit 1
          fi
          storage_account_git=$(grep -E '^storageAccount=' "${config_file}" | tail -n1 | cut -d'=' -f2- | tr -d ' \t\r\n')
          if [ -z "${storage_account_git}" ] || [ "${storage_account_git}" = "changeme" ]; then
            echo "storageAccount in ${config_file} must be set to the Terraform storage_account_name output."
            exit 1
          fi
          storage_account_input=$(printf '%s' "${STORAGE_ACCOUNT_INPUT}" | tr -d ' \t\r\n')
          if [ -z "${storage_account_input}" ]; then
            echo "STORAGE_ACCOUNT input must not be empty."
            exit 1
          fi
          if [ "${storage_account_git,,}" != "${storage_account_input,,}" ]; then
            echo "storageAccount (${storage_account_git}) does not match workflow input (${storage_account_input})."
            exit 1
          fi

      - name: Create IAM namespace early
        shell: bash
        run: |
          set -euo pipefail
          kubectl create namespace "${{ inputs.NAMESPACE_IAM }}" --dry-run=client -o yaml | kubectl apply -f -

      - name: Seed database credentials
        shell: bash
        env:
          NAMESPACE_IAM: ${{ inputs.NAMESPACE_IAM }}
          POSTGRES_SUPERUSER_PASSWORD: ${{ secrets.POSTGRES_SUPERUSER_PASSWORD }}
          KEYCLOAK_DB_PASSWORD: ${{ secrets.KEYCLOAK_DB_PASSWORD }}
          MIDPOINT_DB_PASSWORD: ${{ secrets.MIDPOINT_DB_PASSWORD }}
        run: |
          set -euo pipefail
          if [ -z "${POSTGRES_SUPERUSER_PASSWORD}" ] || [ -z "${KEYCLOAK_DB_PASSWORD}" ] || [ -z "${MIDPOINT_DB_PASSWORD}" ]; then
            echo "Database credentials are required (POSTGRES_SUPERUSER_PASSWORD, KEYCLOAK_DB_PASSWORD, MIDPOINT_DB_PASSWORD)."
            exit 1
          fi
          kubectl -n "${NAMESPACE_IAM}" create secret generic cnpg-superuser \
            --type=kubernetes.io/basic-auth \
            --from-literal=username=postgres \
            --from-literal=password="${POSTGRES_SUPERUSER_PASSWORD}" \
            --dry-run=client -o yaml | kubectl apply -f -
          kubectl -n "${NAMESPACE_IAM}" create secret generic keycloak-db-app \
            --type=kubernetes.io/basic-auth \
            --from-literal=username=keycloak \
            --from-literal=password="${KEYCLOAK_DB_PASSWORD}" \
            --dry-run=client -o yaml | kubectl apply -f -
          kubectl -n "${NAMESPACE_IAM}" create secret generic midpoint-db-app \
            --type=kubernetes.io/basic-auth \
            --from-literal=username=midpoint \
            --from-literal=password="${MIDPOINT_DB_PASSWORD}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Create midPoint administrator secret
        shell: bash
        env:
          NAMESPACE_IAM: ${{ inputs.NAMESPACE_IAM }}
          MIDPOINT_ADMIN_PASSWORD: ${{ secrets.MIDPOINT_ADMIN_PASSWORD }}
        run: |
          set -euo pipefail
          if [ -z "${MIDPOINT_ADMIN_PASSWORD}" ]; then
            echo "MIDPOINT_ADMIN_PASSWORD secret is required."
            exit 1
          fi
          kubectl -n "${NAMESPACE_IAM}" create secret generic midpoint-admin \
            --type=kubernetes.io/basic-auth \
            --from-literal=username=administrator \
            --from-literal=password="${MIDPOINT_ADMIN_PASSWORD}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Normalize Azure Blob credentials for CNPG backups
        shell: bash
        env:
          NAMESPACE_IAM: ${{ inputs.NAMESPACE_IAM }}
          AZURE_STORAGE_ACCOUNT: ${{ inputs.STORAGE_ACCOUNT }}
          AZURE_STORAGE_KEY: ${{ secrets.AZURE_STORAGE_KEY }}
        run: |
          set -euo pipefail
          if [ -z "${AZURE_STORAGE_KEY}" ]; then
            echo "AZURE_STORAGE_KEY secret must provide a storage account key, SAS token, or connection string."
            exit 1
          fi
          python3 scripts/normalize_azure_storage_secret.py \
            --namespace "${NAMESPACE_IAM}" \
            --storage-account "${AZURE_STORAGE_ACCOUNT}" \
            --credential "${AZURE_STORAGE_KEY}"

      - name: Apply GitOps applications
        shell: bash
        run: |
          set -euo pipefail
          kubectl apply -k gitops/clusters/aks

      - name: Wait for platform addons
        shell: bash
        run: |
          set -euo pipefail
          for app in cert-manager cloudnative-pg ingress-nginx; do
            echo "Waiting for Argo CD application ${app}"
            for attempt in $(seq 1 30); do
              sync=$(kubectl -n argocd get application "${app}" -o jsonpath='{.status.sync.status}' 2>/dev/null || true)
              health=$(kubectl -n argocd get application "${app}" -o jsonpath='{.status.health.status}' 2>/dev/null || true)
              if [ "${sync}" = "Synced" ] && [ "${health}" = "Healthy" ]; then
                echo "${app} is synced and healthy"
                break
              fi
              if [ "${attempt}" -eq 30 ]; then
                echo "Timed out waiting for ${app} to become healthy"
                kubectl -n argocd get application "${app}" -o yaml || true
                exit 1
              fi
              sleep 10
            done
          done

      - name: Wait for IAM application
        shell: bash
        run: |
          set -euo pipefail
          for attempt in $(seq 1 60); do
            sync=$(kubectl -n argocd get application iam -o jsonpath='{.status.sync.status}' 2>/dev/null || true)
            health=$(kubectl -n argocd get application iam -o jsonpath='{.status.health.status}' 2>/dev/null || true)
            if [ "${sync}" = "Synced" ] && [ "${health}" = "Healthy" ]; then
              echo "IAM application is synced and healthy"
              exit 0
            fi
            if [ "${attempt}" -eq 60 ]; then
              echo "Timed out waiting for IAM application to become healthy"
              kubectl -n argocd get application iam -o yaml || true
              exit 1
            fi
            sleep 10
          done

      - name: Summary
        shell: bash
        run: |
          set -euo pipefail
          echo "✅ Argo CD and IAM workloads are converged."
          echo "➡️  Run the '04 - Configure demo hosts' workflow to publish nip.io hostnames."
